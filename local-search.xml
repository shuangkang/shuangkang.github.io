<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2024/04/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/04/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-什么是进程？什么是线程？"><a href="#1-什么是进程？什么是线程？" class="headerlink" title="1. 什么是进程？什么是线程？"></a>1. 什么是进程？什么是线程？</h2><ul><li>进程是: 一个应用程序.</li><li>线程是：一个进程中的执行场景&#x2F;执行单元</li><li>一个进程至少有一个线程</li></ul><p>拿Java的HelloWorld来说:</p><ol><li><p>对于Java程序来说，当在DOS命令窗口中运行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Test</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span>&#123;<br> System.out.print(<span class="hljs-string">&quot;Hello World&quot;</span>)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回车之后。会先启动JVM,而JVM就是一个进程。</p></li><li><p>JVM再启动一个主线程调用main方法（main方法就是主线程）。<br>同时再启动一个垃圾回收线程负责看护，回收垃圾。</p></li><li><p>最起码，现在的java程序中至少有两个线程并发，一个是 垃圾回收线程，一个是 执行main方法的主线程。</p></li></ol><h2 id="2-使用多线程有几种方法"><a href="#2-使用多线程有几种方法" class="headerlink" title="2. 使用多线程有几种方法?"></a>2. 使用多线程有几种方法?</h2><p>在Java中，创建多线程有几种主要的方式：</p><h3 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 <strong>继承Thread类</strong></h3><p>这是最基本的创建线程的方式之一。你可以创建一个类，继承自Thread类，并重写其run()方法来定义线程的任务。然后创建该类的实例并调用start()方法来启动线程。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java">javaCopy codeclass MyThread <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的任务逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start(); <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 <strong>实现Runnable接口</strong></h3><p>通过实现Runnable接口，可以将线程的任务逻辑与线程本身解耦，提高代码的灵活性。同样地，创建一个类，实现Runnable接口，并实现其run()方法来定义线程的任务。然后将该实现类的实例传递给Thread类的构造函数，并调用start()方法来启动线程。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">javaCopy codeclass MyRunnable <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的任务逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>        thread.start(); <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 <strong>实现Callable接口</strong></h3><p> 与Runnable接口类似，Callable接口也用于定义线程的任务，但它允许任务返回结果并抛出受检查的异常。可以使用<code>ExecutorService</code>的submit()方法来执行Callable任务。</p><p>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java">javaCopy code<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程执行的任务逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务执行完成&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        Future&lt;String&gt; future = executor.submit(myCallable);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 获取任务执行结果</span><br>        System.out.println(result);<br>        executor.shutdown(); <span class="hljs-comment">// 关闭线程池</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-使用线程池创建"><a href="#2-4-使用线程池创建" class="headerlink" title="2.4 使用线程池创建"></a>2.4 使用线程池创建</h3><h4 id="2-4-1-线程池的参数"><a href="#2-4-1-线程池的参数" class="headerlink" title="2.4.1 线程池的参数"></a>2.4.1 线程池的参数</h4><p><code>ThreadPoolExecutor</code>类允许我们指定核心线程数、最大线程数、线程空闲时间等参数来创建线程池。</p><ul><li><code>corePoolSize</code>: 核心线程数量，决定是否创建新的线程来处理到来的任务</li><li><code>maximumPoolSize</code>: 最大线程数量，线程池中允许创建线程地最大数量</li><li><code>keepAliveTime</code>: 线程空闲时存活的时间</li><li><code>unit</code>: 空闲存活时间单位</li><li><code>workQueue</code>: 任务队列，用于存放已提交的任务</li><li><code>threadFactory</code>: 线程工厂，用于创建线程执行任务</li><li><code>handler</code>: 拒绝策略，当线程池处于饱和时，使用某种策略来拒绝任务提交</li></ul><p>语法结构:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> <br></code></pre></td></tr></table></figure><h4 id="2-4-2-线程池的五种状态"><a href="#2-4-2-线程池的五种状态" class="headerlink" title="2.4.2 线程池的五种状态"></a>2.4.2 线程池的五种状态</h4><ol><li><strong>RUNNING</strong>：线程池处于 RUNNING 状态时，接受新任务，并处理队列中的任务。此时，线程池中的工作线程可以执行任务。处于 RUNNING 状态的线程池可以通过 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法转换为其他状态。</li><li><strong>SHUTDOWN</strong>：线程池处于 SHUTDOWN 状态时，不再接受新任务，但会处理队列中的任务。此时，调用 <code>shutdown()</code> 方法会使线程池转换到 SHUTDOWN 状态。</li><li><strong>STOP</strong>：线程池处于 STOP 状态时，不再接受新任务，不再处理队列中的任务，并且会尝试中断正在执行的任务。调用 <code>shutdownNow()</code> 方法会使线程池转换到 STOP 状态。</li><li><strong>TIDYING</strong>：线程池处于 TIDYING 状态时，所有的任务已经终止，同时工作线程数已经达到了核心线程数。当所有任务都已终止，工作线程数为 0 时，线程池会转换到 TIDYING 状态。TIDYING 状态是用来执行一些清理操作的，例如调用 <code>terminated()</code> 方法。</li><li><strong>TERMINATED</strong>：线程池处于 TERMINATED 状态时，线程池完全终止，不再执行任何任务。当线程池已经终止，且完成了清理操作后，会转换到 TERMINATED 状态。</li></ol><p>这些状态在 <code>ThreadPoolExecutor</code> 类中由 <code>volatile</code> 修饰的 <code>int</code> 常量表示，用于控制线程池的行为和状态转换。通过调用 <code>ThreadPoolExecutor</code> 的不同方法，可以将线程池从一个状态转换到另一个状态，从而实现线程池的管理和控制。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>####2.4.3 线程池的执行流程</p><ol><li><p>如果<code>workerCount</code> &lt; <code>corePoolSize</code> &#x3D;&#x3D;&gt; 创建线程执行提交的任务</p></li><li><p>如果<code>workerCount</code> &gt;&#x3D; <code>corePoolSize</code> &amp;&amp; 阻塞队列未满 &#x3D;&#x3D;&gt; 添加至阻塞队列，等待后续线程来执行提交地任务</p></li><li><p>如果<code>workerCount</code> &gt;&#x3D; <code>corePoolSize</code> &amp;&amp; <code>workerCount</code> &lt; <code>maxinumPoolSize</code> &amp;&amp; 阻塞队列已满  &#x3D;&#x3D;&gt;  创建非核心线程执行提交的任务</p></li><li><p>如果<code>workerCount</code> &gt;&#x3D; <code>maxinumPoolSize</code> &amp;&amp; 阻塞队列已满 &#x3D;&#x3D;&gt; 执行拒绝策略</p></li></ol><p><code>wokerCount</code>: 需要处理的任务总数</p><p><code>corePoolSize</code>: 核心线程</p><p><code>maxinumPoolSize</code>: 最大线程数</p><h4 id="2-4-3-线程池使用示例"><a href="#2-4-3-线程池使用示例" class="headerlink" title="2.4.3 线程池使用示例"></a>2.4.3 线程池使用示例</h4><p>以下是一个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.kangkang;<br><br><br><span class="hljs-keyword">import</span> java.lang.ref.PhantomReference;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThreadPool</span> &#123;<br>    <span class="hljs-comment">//线程参数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>     <span class="hljs-comment">//最大线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//最大队列数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//当线程数大于核心线程数时 如果一个线程空闲时间超过了该参数设置的值,那么该线程就会被终止 直到线程等于核心线程数为止</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//Keep alive time的时间单位 这里设置的是秒</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">UNIT</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS;<br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; BLOCKING_QUEUE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>    <span class="hljs-comment">//创建新线程的工厂</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">THREAD_FACTORY</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br>    <span class="hljs-comment">//拒绝策略 当提交任务无法被接受时的处理策略 这里使用的abortPolicy 会抛出RejectedExecutionException异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">REJECTED_EXECUTION_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy();<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, UNIT,BLOCKING_QUEUE,THREAD_FACTORY,REJECTED_EXECUTION_HANDLER);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>                threadPoolExecutor.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;执行任务&quot;</span> + <span class="hljs-string">&quot;执行次数&quot;</span> + finalI));<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;触发了拒绝策略&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//表示让线程池完成当前任务</span><br>            threadPoolExecutor.shutdown();<br>        &#125;<br><br><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-4-x-如何选择线程池？"><a href="#2-4-x-如何选择线程池？" class="headerlink" title="2.4.x 如何选择线程池？"></a>2.4.x 如何选择线程池？</h4><p>阿里巴巴《Java开发手册》给我们的答案：</p><p><strong>【强制】</strong>线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：<code>Executors</code> 返回的线程池对象的弊端如下：<br>1） <code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>：允许的请求队列长度为 <code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致 OOM。<br>2）<code>CachedThreadPool</code>：允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM(内存泄露)。</p><h2 id="3-Java中的线程调用"><a href="#3-Java中的线程调用" class="headerlink" title="3. Java中的线程调用"></a>3. Java中的线程调用</h2><h3 id="3-1-常见的线程调用模型"><a href="#3-1-常见的线程调用模型" class="headerlink" title="3.1  常见的线程调用模型"></a>3.1  常见的线程调用模型</h3><ul><li><strong>抢占式</strong>调度模型：<br>那个线程的优先级比较高，抢到的CPU时间片的概率就高一些&#x2F;多一些。<br><strong>Java采用的就是抢占式调度模型</strong>。</li><li><strong>均分式</strong>调度模型：<br>平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。<br>平均分配，一切平等。<br>有一些编程语言，线程调度模型采用的是这种方式。</li></ul><h3 id="3-2-Java中线程调用的方法"><a href="#3-2-Java中线程调用的方法" class="headerlink" title="3.2 Java中线程调用的方法"></a>3.2 Java中线程调用的方法</h3><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>int getPriority()</td><td>获得线程优先级</td></tr><tr><td>void setPriority(int newPriority)</td><td>设置线程优先级</td></tr></tbody></table><ul><li>最低优先级1</li><li>默认优先级是5</li><li>最高优先级10</li></ul><p><strong>优先级比较高的获取CPU时间片可能会多一些</strong>。(只是权重会高,实际情况多少会有些出入)</p><p>Thread类中还提供了一些<strong>静态常量</strong>:</p><table><thead><tr><th>常量名</th><th>作用</th></tr></thead><tbody><tr><td><code>MAX_PRIORITY</code></td><td>最高优先级，其值为10。线程被赋予最高优先级时，会优先于其他线程执行，但并不保证一定会先于其他线程执行完毕。</td></tr><tr><td><code>MIN_PRIORITY</code></td><td>最低优先级，其值为1。线程被赋予最低优先级时，会处于最低优先级队列，通常情况下会被较少地调度执行。</td></tr><tr><td><code>NORM_PRIORITY</code></td><td>默认优先级，其值为5。如果没有显式地为线程指定优先级，那么线程会被赋予默认的中等优先级。</td></tr></tbody></table><p><strong>两个线程之间的调度</strong>:</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>yield()</td><td>使当前线程从执行状态（运行状态）变为可运行状态（就绪状态）。</td></tr><tr><td>join()</td><td>允许一个线程等待另一个线程执行完</td></tr></tbody></table><ol><li><code>yield()</code>方法： <code>yield()</code>方法是Thread类的一个静态方法，它使当前线程从执行状态（运行状态）变为可运行状态（就绪状态）。换句话说，它让当前线程暂停执行，让同等优先级的其他线程有机会执行。调用<code>yield()</code>方法并不会释放锁或者让线程进入阻塞状态，仅是一个对线程调度器的建议，因此不能保证线程一定会被调度。一般来说，使用<code>yield()</code>方法是为了让其他线程有机会执行，以提高系统的响应性。</li><li><code>join()</code>方法： <code>join()</code>方法是Thread类的一个实例方法，它允许一个线程等待另一个线程执行完成。调用<code>join()</code>方法的线程将会阻塞，直到被调用的线程执行完成或者指定的等待时间到期。<code>join()</code>方法通常用于在主线程中等待所有子线程执行完成，然后再继续执行后续逻辑。此外，还有<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>方法，允许设置等待时间。</li></ol><h2 id="4-线程安全问题"><a href="#4-线程安全问题" class="headerlink" title="4. 线程安全问题"></a>4. 线程安全问题</h2><h3 id="4-1-什么时候数据在多线程并发的环境下会存在安全问题呢？"><a href="#4-1-什么时候数据在多线程并发的环境下会存在安全问题呢？" class="headerlink" title="4.1.什么时候数据在多线程并发的环境下会存在安全问题呢？"></a>4.1.什么时候数据在多线程并发的环境下会存在安全问题呢？</h3><p><strong>满足三个条件：</strong></p><ul><li>条件1：<strong>多线程并发</strong>。</li><li>条件2：<strong>有共享数据</strong>。</li><li>条件3：<strong>共享数据有修改的行为</strong>。</li></ul><h3 id="4-2-如何解决线程安全问题"><a href="#4-2-如何解决线程安全问题" class="headerlink" title="4.2 如何解决线程安全问题?"></a>4.2 如何解决线程安全问题?</h3><h4 id="4-2-1-使用synchronized关键字"><a href="#4-2-1-使用synchronized关键字" class="headerlink" title="4.2.1 使用synchronized关键字"></a>4.2.1 使用<code>synchronized</code>关键字</h4><p>使用同步方法或同步代码块： 可以使用<code>synchronized</code>关键字来实现同步方法或同步代码块，确保多个线程不会同时访问共享资源，从而避免数据竞争和不一致性。</p><p><strong>synchronized 语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123; <span class="hljs-comment">//这个括号中的对象 必须是多个线程共享的数据的引用  这样才能发挥锁的作用</span><br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-1-1-synchronized-的使用场景"><a href="#4-2-1-1-synchronized-的使用场景" class="headerlink" title="4.2.1.1 synchronized 的使用场景"></a>4.2.1.1 synchronized 的使用场景</h5><ol><li><p>同步代码块： 使用<code>synchronized</code>关键字将代码块包裹起来，确保同一时间只有一个线程可以执行该代码块。需要提供一个对象作为锁，通常使用某个对象实例或者类的静态成员作为锁对象。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-comment">// 同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步方法： 在方法的声明上使用<code>synchronized</code>关键字，使整个方法体成为一个同步代码块，确保同一时间只有一个线程可以执行该方法。同步方法的锁对象是当前对象的实例（对于静态方法则是当前类的Class对象）。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同步类： 在类的声明上使用<code>synchronized</code>关键字，使整个类成为一个同步代码块，确保同一时间只有一个线程可以访问该类的任何同步方法或同步代码块。同步类的锁对象是该类的Class对象。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (SynchronizedClass.class) &#123;<br>            <span class="hljs-comment">// 同步的代码块</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 同步的方法体</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h5 id="4-2-1-2-synchronized实现原理"><a href="#4-2-1-2-synchronized实现原理" class="headerlink" title="4.2.1.2 synchronized实现原理:"></a>4.2.1.2 synchronized实现原理:</h5><p>在Java中，每个对象都有一个对象头（Object Header），对象头中包含了一些与对象自身相关的信息，其中包括对象的哈希码、锁状态标志等。在使用<code>synchronized</code>关键字时，<strong>JVM会使用对象头中的锁状态来实现同步。</strong></p><p>具体来说，当一个线程执行到<code>synchronized</code>代码块或方法时，它会尝试获取对象的锁。如果这个对象的锁状态为无锁状态（即没有任何线程持有锁），那么该线程就可以获取到锁，并将锁状态设置为锁定状态。如果这个对象的锁状态为锁定状态，并且是由其他线程持有的，那么当前线程就会被阻塞，直到持有锁的线程释放锁。</p><p>在Java中，锁状态通常被表示为一个标志位（1表示锁定状态，0表示无锁状态），因此<code>synchronized</code>关键字的底层原理其实就是通过对象头中的锁状态来实现线程同步的。</p><p>####4.2.2 使用<code>volatile</code>关键字</p><p> 在多线程环境中，volatile关键字可以确保可见性，即一个线程对volatile变量的修改会立即被其他线程所感知，从而避免出现脏读或者数据不一致的问题。</p><p>假设我们有一个简单的场景：一个变量被两个线程访问和修改。其中，一个线程不断读取这个变量的值，另一个线程不断更新这个值。如果这个变量被声明为 <code>volatile</code>，那么任何一个线程对这个变量的修改都会立即反映给另外一个线程；反之，如果不使用 <code>volatile</code>，则一个线程修改的值可能对另一个线程不可见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">javaCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-comment">// 使用volatile关键字修饰共享变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 线程1不断读取flag的值</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (!flag) &#123;<br>                <span class="hljs-comment">// 这里不做任何事情，只是循环检查flag的值</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;线程1感知到flag的变化&quot;</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 保证线程1先运行</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 线程2修改flag的值</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;线程2修改了flag的值&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>flag</code> 被声明为 <code>volatile</code> 类型。这意味着，当线程2修改了 <code>flag</code> 的值时，线程1几乎立即就能感知到 <code>flag</code> 值的变化，并跳出循环，输出提示信息。如果我们去掉 <code>volatile</code> 关键字，就不能保证线程1能够及时感知到 <code>flag</code> 的变化，甚至可能会导致线程1永远处于循环中，因为线程1可能会把 <code>flag</code> 的初值缓存在自己的工作内存中，而忽略主内存中 <code>flag</code> 的更新。</p><h5 id="4-2-2-1-volatile-无法保证原子性"><a href="#4-2-2-1-volatile-无法保证原子性" class="headerlink" title="4.2.2.1 volatile 无法保证原子性"></a>4.2.2.1 volatile 无法保证原子性</h5><p>虽然<code>volatile</code> 保证了变量修改的<strong>可见性</strong>但是它不涉及锁定，因此不保证<strong>操作</strong>的<strong>原子性</strong></p><p>比如 i++这样的操作</p><p>像 <code>i++</code> 这样的自增操作之所以不能仅通过 <code>volatile</code> 来保证线程安全，是因为 <code>i++</code> 实际上是一个复合操作，包含了三个独立的步骤：读取变量的当前值、增加变量的值、写回新值到变量。这三个步骤不是原子性的，当多个线程同时执行这样的操作时，它们之间可能会互相干扰，导致数据不一致的问题。</p><p>来具体分析一下过程：</p><ol><li>**读取 (<code>read</code>)**：首先，线程读取 <code>i</code> 当前的值到自己的工作内存中。</li><li>**增加 (<code>increment</code>)**：然后，线程在自己的工作内存中将 <code>i</code> 的值加1。</li><li>**写回 (<code>write</code>)**：最后，线程将更新后的值写回到主内存中。</li></ol><p>在多线程环境中，如果两个或多个线程几乎同时执行这个操作，它们可能都会在自己的工作内存中读取到 <code>i</code> 的相同值，然后各自增加1，并写回新值到主内存中。这样就会导致 <code>i</code> 实际上被增加了多次，但结果只增加了1次，因为多个线程读取和写回的操作互相覆盖了。</p><p>即使 <code>i</code> 被声明为 <code>volatile</code>，虽然每次写操作都会立即同步到主内存中，确保了可见性，但是由于 <code>i++</code> 的复合操作性质，它不能保证在读-改-写这整个过程中的原子性。因此，在并发环境下，仅仅依靠 <code>volatile</code> 关键字是不足以使 <code>i++</code> 操作成为线程安全的。</p><p>要安全地实现 <code>i++</code> 操作，可以使用如下方法：</p><ul><li>使用 <code>synchronized</code> 关键字或锁（如 <code>ReentrantLock</code>）来确保每次只有一个线程可以执行这个操作。</li><li>使用 <code>AtomicInteger</code> 这类的原子类，Java 并发包中提供了这种线程安全的数字操作类，它们可以保证此类操作的原子性。</li></ul><h5 id="4-2-2-2-volatile-的底层原理"><a href="#4-2-2-2-volatile-的底层原理" class="headerlink" title="4.2.2.2 volatile 的底层原理"></a>4.2.2.2 volatile 的底层原理</h5><ol><li><strong>内存可见性</strong></li></ol><ul><li>主内存与工作内存：在Java内存模型中，所有变量都存储在主内存中，而每个线程都有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的数据。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li><li><strong>可见性保证</strong>：当变量被声明为 <code>volatile</code> 后，线程对这个变量的修改会立即强制刷新到主内存中，同时，每次使用这个变量之前，都会从主内存中重新读取它的值，而不是使用工作内存中的缓存。这就保证了一个线程修改了某个 <code>volatile</code> 变量的值后，其他线程能够立即看到这一变化。</li></ul><ol start="2"><li><strong>禁止指令重排序</strong></li></ol><ul><li>指令重排序：在不影响单线程程序执行结果的前提下，编译器和处理器为了优化程序性能可能会对指令序列进行重排序。但是，在多线程环境中，这种重排序可能会破坏线程安全。</li><li>有序性保证：<code>volatile</code> 变量的另一个关键作用是禁止对其读写操作的指令重排序，确保在它之前的操作都不会被重排到它之后，它之后的操作也不会被重排到它之前。这样，即使在多线程环境中，也能保证基于 <code>volatile</code> 变量的操作顺序符合预期。</li></ul><ol start="3"><li><strong>底层支持</strong></li></ol><p>实现 <code>volatile</code> 的底层支持主要依赖于处理器的内存屏障指令：</p><ul><li>内存屏障（Memory Barrier）：是一种处理器指令，用于实现对内存操作的顺序限制。内存屏障有多种类型，每种类型都有其特定的作用，如确保某些特定操作的执行顺序，防止指令之间的重排序等。</li><li>当写入一个 <code>volatile</code> 变量时，会在写操作后插入一条存储屏障（Store Barrier），确保对这个 <code>volatile</code> 变量的写操作对其他线程立即可见（通过将当前处理器缓存行的数据写回到系统内存）。</li><li>当读取一个 <code>volatile</code> 变量时，会在读操作前插入一条加载屏障（Load Barrier），确保对这个 <code>volatile</code> 变量的读操作能够看到最新的值（通过无效化当前处理器缓存行，强制从系统内存中读取）。</li></ul><h4 id="4-2-3-使用Lock接口"><a href="#4-2-3-使用Lock接口" class="headerlink" title="4.2.3 使用Lock接口"></a>4.2.3 使用<code>Lock</code>接口</h4><p> Java提供了Lock接口及其实现类（如<code>ReentrantLock</code>），通过Lock接口可以实现更灵活和精确的锁定机制，避免了使用synchronized关键字可能出现的一些问题，例如死锁。</p><h5 id="4-2-3-1-Lock的核心方法"><a href="#4-2-3-1-Lock的核心方法" class="headerlink" title="4.2.3.1 Lock的核心方法"></a>4.2.3.1 Lock的核心方法</h5><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>void lock()</code></td><td>获取锁。如果锁不可用，则当前线程将处于休眠状态直到锁被释放。</td></tr><tr><td><code>void lockInterruptibly() throws InterruptedException</code></td><td>如果当前线程未被中断，则获取锁。如果已经被中断，则抛出一个 <code>InterruptedException</code></td></tr><tr><td><code>boolean tryLock()</code></td><td>尝试获取锁，如果锁可用立即返回 true，否则返回 false。该方法会立即返回，不会等待。</td></tr><tr><td><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></td><td>如果锁在给定等待时间内变得可用，并且当前线程未被中断，则获取锁。</td></tr><tr><td><code>void unlock()</code></td><td>释放锁</td></tr><tr><td><code>Condition newCondition()</code></td><td>返回绑定到此 <code>Lock</code> 实例的新 <code>Condition</code> 实例。</td></tr></tbody></table><h5 id="4-2-3-2-Lock示例"><a href="#4-2-3-2-Lock示例" class="headerlink" title="4.2.3.2 Lock示例"></a>4.2.3.2 Lock示例</h5><p>下面是一个使用 <code>ReentrantLock</code> 类（<code>Lock</code> 接口的一个实现）的示例，展示了如何在代码中使用它来实现同步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java">javaCopy code<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(); <span class="hljs-comment">// 创建一个 ReentrantLock 实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 在修改前获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock(); <span class="hljs-comment">// 在修改后释放锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Counter</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br>        <br>        <span class="hljs-comment">// 创建并启动线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                counter.increment();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                counter.increment();<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.join();<br>            t2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Final count is: &quot;</span> + counter.getCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <code>synchronized</code> 相比</p><ul><li><strong>灵活性</strong>：<code>Lock</code> 提供了更灵活的锁定操作，允许尝试非阻塞地获取锁、尝试可中断地获取锁以及在指定的等待时间内获取锁。</li><li><strong>公平性</strong>：某些 <code>Lock</code> 实现（如 <code>ReentrantLock</code>）允许你构建公平锁，这种锁会按照线程等待的顺序来获取锁。</li><li><strong>锁绑定多个条件</strong>：<code>Lock</code> 允许一个锁关联一个或多个条件对象（<code>Condition</code> 类），这可以分开管理不同的等待线程集合，提供了类似 <code>Object</code> 监视器方法（<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>）的功能，但更灵活。</li></ul><p>使用 <code>Lock</code> 还是 <code>synchronized</code> 取决于具体的应用场景和对灵活性、响应中断、定时锁等待、公平性锁定等的需求。</p><h5 id="4-2-3-3-Lock的底层原理"><a href="#4-2-3-3-Lock的底层原理" class="headerlink" title="4.2.3.3 Lock的底层原理"></a>4.2.3.3 Lock的底层原理</h5><p><code>Lock</code> 接口的实现，尤其是 <code>ReentrantLock</code>，是基于 Java 并发包 <code>java.util.concurrent</code> 中的高级同步机制实现的。它的底层原理较为复杂，涉及到多种并发编程的基本概念，包括但不限于：CAS（Compare-And-Swap）操作、AQS（<code>AbstractQueuedSynchronizer</code>）框架、以及Java内存模型（JMM）。下面是对这些概念和 <code>ReentrantLock</code> 底层工作原理的简要说明：</p><hr><ol><li><strong>CAS（Compare-And-Swap）</strong></li></ol><ul><li><strong>基础</strong>：CAS 是一种原子操作，用于实现变量的无锁编程。它包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。只有当内存位置的值与预期原值相匹配时，系统才将该位置值更新为新值。这个操作是原子的，即中间不会被线程调度机制打断。</li><li><strong>用途</strong>：在 <code>ReentrantLock</code> 的实现中，CAS 用来实现锁状态的管理，比如尝试获取锁时更新状态值。</li></ul><ol start="2"><li><strong>AQS</strong>（<code>AbstractQueuedSynchronizer</code>）</li></ol><ul><li><strong>核心</strong>：AQS 是构建锁或其他同步器的框架，提供了一个基于FIFO队列的框架，用于管理等待获取锁的线程。它使用一个int成员变量表示同步状态，通过内置的FIFO队列来管理那些失败获取同步状态的线程。</li><li><strong>同步状态</strong>：AQS 使用一个整型的变量来表示同步状态，并通过protected方法来改变这个状态。锁实现者可以根据自己的需要来决定状态的意义。</li><li><strong>节点和队列</strong>：AQS 内部通过一个名为 <code>Node</code> 的静态嵌套类来表示等待队列中的每一个元素，每个节点包含了一个线程引用。当线程尝试获取锁而失败时，AQS 会将该线程包装成一个节点加入到等待队列的尾部；当锁被释放时，头节点的线程会尝试再次获取锁。</li></ul><ol start="3"><li><strong>锁的获取与释放</strong></li></ol><ul><li><strong>获取锁</strong>：当线程尝试获取锁时，<code>ReentrantLock</code> 首先尝试通过CAS设置同步状态，如果成功（意味着没有其他线程持有锁），则拥有了锁。如果失败，AQS会将当前线程封装成节点放入等待队列，同时线程将会被阻塞。</li><li><strong>释放锁</strong>：当锁持有者线程释放锁时，<code>ReentrantLock</code> 会更新同步状态并检查等待队列是否有因等待锁而阻塞的线程，如果有，将会选择一个（通常是队列头部的）线程来尝试获取锁。</li></ul><ol start="4"><li><strong>公平性和非公平性</strong></li></ol><ul><li><p><code>ReentrantLock</code> 提供了公平锁和非公平锁两种模式。公平锁意味着锁的分配会遵循队列中等待时间最长的线程优先的原则；非公平锁则允许插队，可能会导致等待时间较长的线程出现饥饿现象。</p></li><li><p>公平锁在锁释放时总是选择等待时间最长的线程来获取锁，而非公平锁则允许其他线程抢占，从而可能直接获取锁。</p><hr></li></ul><p><strong>总结</strong></p><p><code>ReentrantLock</code> 的实现复杂且高效，它通过结合CAS操作、AQS框架以及Java内存模型（JMM）提供的内存可见性保证，实现了一种比传统 <code>synchronized</code> 方法更灵活、更高性能的线程同步机制。</p><h4 id="4-2-4-使用并发容器"><a href="#4-2-4-使用并发容器" class="headerlink" title="4.2.4 使用并发容器"></a>4.2.4 使用并发容器</h4><p>Java提供了一些并发安全的容器类，例如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等，这些容器类在多线程环境下可以安全地访问和修改共享数据。</p><p><code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code> 都是 Java 中的并发集合，设计用于在多线程环境中提供高性能的线程安全性。它们通过具体的策略来最小化锁的竞争，从而提高并发访问的效率。下面分别介绍这两个类的特点和工作原理。</p><hr><h5 id="4-2-4-1-ConcurrentHashMap"><a href="#4-2-4-1-ConcurrentHashMap" class="headerlink" title="4.2.4.1 ConcurrentHashMap"></a>4.2.4.1 <code>ConcurrentHashMap</code></h5><p><code>ConcurrentHashMap</code> 是一个线程安全的哈希表，用于在多线程环境中替代同步的 <code>HashMap</code> (<code>Collections.synchronizedMap(new HashMap&lt;...&gt;())</code>)。它通过分段锁（Segmentation）的概念提供了比 <code>Hashtable</code> 更好的并发性能。</p><ul><li><p><strong>分段锁</strong>：<code>ConcurrentHashMap</code> 将数据分成一段一段存储，然后给每一段数据配上一把锁。当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code> 默认将数据分为 16 段，每当进行修改操作时，只需锁定相应的段，而不是锁定整个哈希表。</p></li><li><p><strong>读取不加锁</strong>：对于读取操作，<code>ConcurrentHashMap</code> 不加锁，因为它在内部采用了一种不可变的数据结构，即使没有加锁，也可以保证读取操作的安全性。</p></li><li><p><strong>迭代器弱一致性</strong>：<code>ConcurrentHashMap</code> 的迭代器（和集合视图）提供了弱一致性，而不是快速失败（fail-fast）。这意味着迭代器在创建后不会抛出 <code>ConcurrentModificationException</code>，它们可以容忍并发的修改。</p><hr></li></ul><h5 id="4-2-4-2-CopyOnWriteArrayList"><a href="#4-2-4-2-CopyOnWriteArrayList" class="headerlink" title="4.2.4.2 CopyOnWriteArrayList"></a>4.2.4.2 <code>CopyOnWriteArrayList</code></h5><p><code>CopyOnWriteArrayList</code> 是一个线程安全的 <code>List</code> 实现，适用于读多写少的并发场景。如其名，该类的核心思想是“写入时复制”（Copy-On-Write）。</p><ul><li><p><strong>写入时复制</strong>：每当我们尝试修改（添加、删除、设置等）<code>CopyOnWriteArrayList</code> 中的内容时，它实际上会先复制一份数据，然后在这份新的副本上进行修改。修改完成后，再将原来的引用指向新的副本。这样读取操作仍然可以安全地执行，而不受并发修改的影响。</p></li><li><p><strong>迭代器不支持修改</strong>：<code>CopyOnWriteArrayList</code> 的迭代器不支持 <code>remove</code>、<code>add</code> 和 <code>set</code> 操作，抛出 <code>UnsupportedOperationException</code>。</p></li><li><p><strong>读取性能高</strong>：由于读取操作不需要加锁，所以在读多写少的场景下，<code>CopyOnWriteArrayList</code> 的读取性能非常高。</p></li><li><p><strong>内存开销</strong>：由于每次修改都要复制整个底层数组，<code>CopyOnWriteArrayList</code> 在内存使用上比较昂贵，特别是当列表很大时。因此，它通常适用于包含少量修改操作的场景。</p><hr><p><strong>总结</strong></p></li></ul><p><code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code> 都是解决并发环境下集合操作的有效工具，它们通过不同的策略（分段锁和写入时复制）来提高并发性能和线程安全。选择哪一个取决于具体的应用场景：<code>ConcurrentHashMap</code> 适用于高并发的键值对操作，而 <code>CopyOnWriteArrayList</code> 更适用于读操作远远多于写操作的列表处理场景。</p><h4 id="4-2-5-使用原子类"><a href="#4-2-5-使用原子类" class="headerlink" title="4.2.5 使用原子类"></a>4.2.5 使用原子类</h4><p>Java提供了一系列的原子类，例如<code>AtomicInteger</code>、<code>AtomicLong</code>等，它们提供了一些原子操作，可以在不使用锁的情况下实现线程安全的操作。</p><h4 id="4-2-6-避免死锁"><a href="#4-2-6-避免死锁" class="headerlink" title="4.2.6 避免死锁"></a>4.2.6 避免死锁</h4><p>在设计多线程程序时要注意避免死锁的发生，即避免多个线程之间相互等待对方持有的资源而无法继续执行的情况。</p><h4 id="4-2-7-使用线程安全的第三方库"><a href="#4-2-7-使用线程安全的第三方库" class="headerlink" title="4.2.7 使用线程安全的第三方库"></a>4.2.7 使用线程安全的第三方库</h4><p>在开发过程中，可以使用一些已经经过验证的线程安全的第三方库，如Apache Commons中的并发工具类。</p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio</title>
    <link href="/2024/03/29/Minio/"/>
    <url>/2024/03/29/Minio/</url>
    
    <content type="html"><![CDATA[<h1 id="Minio"><a href="#Minio" class="headerlink" title="Minio"></a>Minio</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>MinIO 是一个开源的对象存储服务器，它允许用户通过简单的 HTTP REST API 来存储和检索任意数量的数据。MinIO 是一个轻量级、高性能的分布式存储系统，专门设计用于大规模数据存储和处理。</p><p>以下是 MinIO 的一些主要特点和优势：</p><ol><li><strong>高性能</strong>: MinIO 使用 Go 语言编写，具有出色的性能和并发处理能力。它可以在常见硬件上实现接近线性的扩展性。</li><li><strong>易用性</strong>: MinIO 的 API 遵循 S3 协议，因此与许多现有的 S3 兼容客户端和工具兼容。这使得使用 MinIO 变得非常容易，并且可以与许多现有的应用程序和工具集成。</li><li><strong>分布式架构</strong>: MinIO 具有分布式架构，可以将数据水平扩展到多个节点，以实现高可用性和容错性。</li><li><strong>安全性</strong>: MinIO 提供了多种安全功能，包括针对数据的加密传输和加密存储，以及针对访问控制的权限管理机制。</li><li><strong>灵活性</strong>: MinIO 可以部署在公共云、私有云或混合云环境中，同时还支持容器化部署。</li></ol><p>总的来说，MinIO 提供了一个高性能、易用和灵活的对象存储解决方案，适用于各种场景，包括大规模数据存储、数据湖、备份和归档等。</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><h3 id="2-1导入依赖"><a href="#2-1导入依赖" class="headerlink" title="2.1导入依赖"></a>2.1导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.minio<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>minio<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-文件上传"><a href="#2-2-文件上传" class="headerlink" title="2.2 文件上传"></a>2.2 文件上传</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> io.minio.MinioClient;<br><span class="hljs-keyword">import</span> io.minio.ObjectWriteResponse;<br><span class="hljs-keyword">import</span> io.minio.PutObjectArgs;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateFile</span> &#123;<br>    <span class="hljs-meta">@Test</span> <span class="hljs-comment">//测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//加载客户端对象</span><br>        <span class="hljs-type">MinioClient</span> <span class="hljs-variable">minioClient</span> <span class="hljs-operator">=</span><br>                MinioClient.builder()<br>                        .endpoint(<span class="hljs-string">&quot;http://111.45.25.85:9000&quot;</span>) <span class="hljs-comment">//minio主机</span><br>                        .credentials(<span class="hljs-string">&quot;minio&quot;</span>, <span class="hljs-string">&quot;minio123&quot;</span>) <span class="hljs-comment">//minio服务器用户名和密码</span><br>                        .build();<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\桌面的文件夹\\桌面壁纸\\default.png&quot;</span>); <span class="hljs-comment">//需要上传的文件路径</span><br>        <span class="hljs-type">ObjectWriteResponse</span> <span class="hljs-variable">kangkang</span> <span class="hljs-operator">=</span> minioClient.putObject(<br>                PutObjectArgs.builder()<br>                        .bucket(<span class="hljs-string">&quot;kangkang&quot;</span>)  <span class="hljs-comment">//bucket桶的名称</span><br>                        .object(<span class="hljs-string">&quot;文件/default.png&quot;</span>)  <span class="hljs-comment">//需要上传到哪个目录</span><br>                        .stream(image, image.available(), -<span class="hljs-number">1</span>)  <span class="hljs-comment">//放入流中 </span><br>                        .contentType(<span class="hljs-string">&quot;image/png&quot;</span>)  <span class="hljs-comment">//文件类型</span><br>                        .build()<br>        );<br>        System.out.println(kangkang);<br><br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对象存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2024/03/24/RabbitMQ/"/>
    <url>/2024/03/24/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>RabbitMQ是一个开源的消息代理和队列服务器，用来通过共同的协议传递消息，支持多种消息协议。它是用Erlang语言编写的，因此具有高并发和高可靠性的特点。RabbitMQ允许软件应用程序之间的松散耦合，这意味着系统的不同部分可以独立地接收、处理和转发消息，从而提高了系统的灵活性和可扩展性。</p><p><strong>RabbitMQ与OpenFeign的区别:</strong></p><ul><li><strong>通信方式</strong>：OpenFeign 实现了同步的服务间调用，而 RabbitMQ 提供了异步的消息传递能力。</li><li><strong>使用场景</strong>：OpenFeign 适用于对实时性要求高(实现同步牺牲性能)的直接服务调用，RabbitMQ 适合于需要异步处理、消息可靠传递或者实现系统间解耦的场景。(不追求同步提升性能)</li><li><strong>技术栈</strong>：OpenFeign 主要在 Spring Cloud 环境中使用，用于简化微服务之间的HTTP调用；RabbitMQ 作为一个独立的消息队列服务，可以被任何能够与其通信的应用程序所使用，不限于 Java 或 Spring 应用。</li></ul><h2 id="2-管控台操作"><a href="#2-管控台操作" class="headerlink" title="2. 管控台操作"></a>2. 管控台操作</h2><p>访问默认的15672端口来使用RadditMQ的管控台</p><h3 id="2-1-消息队列配置"><a href="#2-1-消息队列配置" class="headerlink" title="2.1 消息队列配置"></a>2.1 消息队列配置</h3><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/RedditMQ/%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%971.png"></p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/RedditMQ/%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%972.png"></p><h3 id="2-2-交换机配置"><a href="#2-2-交换机配置" class="headerlink" title="2.2 交换机配置"></a>2.2 交换机配置</h3><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/RedditMQ/%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA1.png"></p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/RedditMQ/%E5%88%9B%E5%BB%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA2.png"></p><h2 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h2><h3 id="3-1-导入SpringAMQP依赖"><a href="#3-1-导入SpringAMQP依赖" class="headerlink" title="3.1 导入SpringAMQP依赖"></a>3.1 导入SpringAMQP依赖</h3><p>RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>使用SpringAMQP需要加入相应的依赖 <strong>生产者和消费者都需要</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-配置application-yml文件"><a href="#3-2-配置application-yml文件" class="headerlink" title="3.2 配置application.yml文件"></a>3.2 配置application.yml文件</h3><p><strong>生产者和消费者都需要</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 你的虚拟机IP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">myhost</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h3 id="3-3-“Hello-World-”-简单的模式"><a href="#3-3-“Hello-World-”-简单的模式" class="headerlink" title="3.3  “Hello World!” 简单的模式"></a>3.3  “Hello World!” 简单的模式</h3><h4 id="3-3-1-创建消息队列"><a href="#3-3-1-创建消息队列" class="headerlink" title="3.3.1 创建消息队列"></a>3.3.1 创建消息队列</h4><p>作为容器注入由Spring管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//表示创建一个消息队列名称为 simple.queue</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;simple.queue&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-配置消费者接收"><a href="#3-3-2-配置消费者接收" class="headerlink" title="3.3.2 配置消费者接收"></a>3.3.2 配置消费者接收</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  <span class="hljs-comment">//接受这个队列的消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleSimpleQueue</span><span class="hljs-params">(String message)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;消费者收到的消息:&#123;&#125;&quot;</span>, message);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-3-3-配置生产者发送"><a href="#3-3-3-配置生产者发送" class="headerlink" title="3.3.3 配置生产者发送"></a>3.3.3 配置生产者发送</h4><p>使用测试类发送,实际场景中可以直接注入<code>RabbitTemplate</code>直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublisherApplicationTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 简单模式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleQueueTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//参数一：RoutingKey，路由Key，简单模式，写的就是队列名称</span><br>        <span class="hljs-comment">//参数二：消息内容</span><br><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;simple.queue&quot;</span>, <span class="hljs-string">&quot;你好啊!!&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-WorkQueues模型"><a href="#3-4-WorkQueues模型" class="headerlink" title="3.4  WorkQueues模型"></a>3.4  WorkQueues模型</h3><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos</title>
    <link href="/2024/03/21/Nacos/"/>
    <url>/2024/03/21/Nacos/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Nacos 是一个开源的动态服务发现、配置管理和服务管理平台，最初由阿里巴巴公司开发。</p><p>它提供了一种简单和强大的方式来实现微服务架构中的服务注册、发现和配置管理。</p><p>Nacos 的核心功能包括<strong>服务注册</strong>与<strong>发现、动态配置管理</strong>、<strong>服务健康监测</strong>以及<strong>动态 DNS 服务</strong>等。通过 Nacos，开发人员可以轻松地管理和发现各种微服务，实现了微服务架构中的解耦和弹性扩展。</p><p>官方文档入口:<a href="https://nacos.io/docs/latest/what-is-nacos/">什么是 Nacos | Nacos</a></p><h2 id="2-为什么需要Nacos"><a href="#2-为什么需要Nacos" class="headerlink" title="2.为什么需要Nacos?"></a>2.为什么需要Nacos?</h2><ol><li><p>微服务中有很多相同的配置,如何实现共享一份?</p></li><li><p>服务中业务数据可能会发生变化,每次修改都要重启服务.</p></li></ol><h2 id="3-注册服务发现"><a href="#3-注册服务发现" class="headerlink" title="3.注册服务发现"></a>3.注册服务发现</h2><h3 id="3-1-导入Nacos依赖"><a href="#3-1-导入Nacos依赖" class="headerlink" title="3.1 导入Nacos依赖"></a>3.1 导入Nacos依赖</h3><p>注意自己引入版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-配置application-yaml文件"><a href="#3-2-配置application-yaml文件" class="headerlink" title="3.2  配置application.yaml文件"></a>3.2  配置application.yaml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># 你的nacos地址</span><br></code></pre></td></tr></table></figure><h2 id="4-配置中心"><a href="#4-配置中心" class="headerlink" title="4. 配置中心"></a>4. 配置中心</h2><h3 id="4-1-导入Nacos配置中心的依赖"><a href="#4-1-导入Nacos配置中心的依赖" class="headerlink" title="4.1 导入Nacos配置中心的依赖"></a>4.1 导入Nacos配置中心的依赖</h3><p>每个需要<code>Nacos</code>配置的Module都需导入这些依赖</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml">  <span class="hljs-string">&lt;!--nacos配置管理--&gt;</span><br>  <span class="hljs-string">&lt;dependency&gt;</span><br>      <span class="hljs-string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br>      <span class="hljs-string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br>  <span class="hljs-string">&lt;/dependency&gt;</span><br>  <span class="hljs-string">&lt;!--读取bootstrap文件--&gt;</span><br>  <span class="hljs-string">&lt;dependency&gt;</span><br>      <span class="hljs-string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br>      <span class="hljs-string">&lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br>  <span class="hljs-string">&lt;/dependency&gt;</span><br>  <span class="hljs-string">&lt;!--nacos</span> <span class="hljs-string">服务注册发现--&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br>       <span class="hljs-string">&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br>       <span class="hljs-string">&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="4-2-配置Nacos中的配置中心"><a href="#4-2-配置Nacos中的配置中心" class="headerlink" title="4.2 配置Nacos中的配置中心"></a>4.2 配置<code>Nacos</code>中的配置中心</h3><h4 id="4-2-1-数据库和Mybatis-Plus配置"><a href="#4-2-1-数据库和Mybatis-Plus配置" class="headerlink" title="4.2.1 数据库和Mybatis-Plus配置"></a>4.2.1 数据库和Mybatis-Plus配置</h4><p>注意这里的jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:101.35.55.85&#125;</code>配置了默认值为<code>101.35.55.85</code>，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定，无默认值</li><li>后端本地配置大于<code>Nacos</code>配置中心的配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://$&#123;hm.db.host:101.35.55.85&#125;:3306/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;hm.db.pw:123&#125;</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">update-strategy:</span> <span class="hljs-string">not_null</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-Swagger-配置"><a href="#4-2-2-Swagger-配置" class="headerlink" title="4.2.2 Swagger 配置"></a>4.2.2 Swagger 配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">knife4j:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">openapi:</span><br>    <span class="hljs-attr">title:</span> <span class="hljs-string">$&#123;hm.swagger.title:黑马商城接口文档&#125;</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">$&#123;hm.swagger.description:黑马商城接口文档&#125;</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">$&#123;hm.swagger.email:zhanghuyi@itcast.cn&#125;</span><br>    <span class="hljs-attr">concat:</span> <span class="hljs-string">$&#123;hm.swagger.concat:虎哥&#125;</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">https://www.itcast.cn</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.0</span><br>    <span class="hljs-attr">group:</span><br>      <span class="hljs-attr">default:</span><br>        <span class="hljs-attr">group-name:</span> <span class="hljs-string">default</span><br>        <span class="hljs-attr">api-rule:</span> <span class="hljs-string">package</span><br>        <span class="hljs-attr">api-rule-resources:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;hm.swagger.package&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-2-3-日志配置"><a href="#4-2-3-日志配置" class="headerlink" title="4.2.3 日志配置"></a>4.2.3 日志配置</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol">  level:</span><br>    com.hmall: debug<br><span class="hljs-symbol">  pattern:</span><br><span class="hljs-symbol">    dateformat:</span> HH:mm:ss:SSS<br><span class="hljs-symbol">  file:</span><br><span class="hljs-symbol">    path:</span> <span class="hljs-string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-后端配置"><a href="#4-3-后端配置" class="headerlink" title="4.3 后端配置"></a>4.3 后端配置</h3><h4 id="4-3-1-配置bootstrap-yaml文件"><a href="#4-3-1-配置bootstrap-yaml文件" class="headerlink" title="4.3.1 配置bootstrap.yaml文件"></a>4.3.1 配置bootstrap.yaml文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cart-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">101.35</span><span class="hljs-number">.55</span><span class="hljs-number">.85</span> <span class="hljs-comment"># nacos地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 共享配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-jdbc.yaml</span> <span class="hljs-comment"># 共享mybatis配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span> <span class="hljs-comment"># 共享日志配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-swagger.yaml</span> <span class="hljs-comment"># 共享日志配置</span><br>            <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>            <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 配置是否动态刷新</span><br><br><span class="hljs-attr">hm:</span><br>  <span class="hljs-attr">swagger:</span><br>    <span class="hljs-attr">title:</span> <span class="hljs-string">购物车服务接口文档</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">com.hmall.cart.controller</span><br><br></code></pre></td></tr></table></figure><h4 id="4-3-2-完善数据库连接配置"><a href="#4-3-2-完善数据库连接配置" class="headerlink" title="4.3.2 完善数据库连接配置"></a>4.3.2 完善数据库连接配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hm:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">101.35</span><span class="hljs-number">.55</span><span class="hljs-number">.85</span> <span class="hljs-comment"># 修改为你自己的虚拟机IP地址</span><br>    <span class="hljs-attr">pw:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 修改为docker中的MySQL密码</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-string">hm-cart</span>  <span class="hljs-comment">#增加这句来指定相应的数据库</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3-减去相应的配置"><a href="#4-3-3-减去相应的配置" class="headerlink" title="4.3.3 减去相应的配置"></a>4.3.3 减去相应的配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">101.35</span><span class="hljs-number">.55</span><span class="hljs-number">.85</span><span class="hljs-string">:8848</span> <br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><h3 id="4-4-实现热更新配置"><a href="#4-4-实现热更新配置" class="headerlink" title="4.4 实现热更新配置"></a>4.4 实现热更新配置</h3><h4 id="4-4-1-Nacos新增配置"><a href="#4-4-1-Nacos新增配置" class="headerlink" title="4.4.1 Nacos新增配置"></a>4.4.1 Nacos新增配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hm:</span><br>  <span class="hljs-attr">cart:</span><br>    <span class="hljs-attr">maxNum:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 购物车商品数量上限</span><br></code></pre></td></tr></table></figure><h4 id="4-4-2-修改后端代码"><a href="#4-4-2-修改后端代码" class="headerlink" title="4.4.2 修改后端代码"></a>4.4.2 修改后端代码</h4><h5 id="方式一-适合单个属性"><a href="#方式一-适合单个属性" class="headerlink" title="方式一 适合单个属性"></a>方式一 适合单个属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@RefreshScope</span> # 在类名上添加注解 开启热更新<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICartService</span> &#123;<br><br><br>#注入属性    <br><span class="hljs-meta">@Value(&quot;$&#123;hm.cart.maxNum&#125;&quot;)</span><br><span class="hljs-keyword">private</span> Integer maxNum;<br>    <br><br>#添加判断<br>   <span class="hljs-comment">//方法二</span><br>        <span class="hljs-keyword">if</span> (count&gt;= maxNum)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizIllegalException</span>(StrUtil.format(<span class="hljs-string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, maxNum));<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="方式二-适合多个属性"><a href="#方式二-适合多个属性" class="headerlink" title="方式二 适合多个属性"></a>方式二 适合多个属性</h5><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmall.cart.config;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过配置文件自动绑定属性值到该类的字段上。</span><br><span class="hljs-comment"> * 使用lombok简化了getter和setter方法的编写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span> <span class="hljs-comment">// Lombok注解，自动生成getter和setter方法，以及toString、equals、hashCode方法</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 表明该类是一个组件，Spring会自动检测并注册到ApplicationContext中</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span> <span class="hljs-comment">// 指定配置属性的前缀，用于绑定nacos配置文件中的属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartProperties</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 购物车最大商品数量。</span><br><span class="hljs-comment">     * 配置属性示例：hm.cart.maxAmount=100</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer maxNum;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>直接使用类属性 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//配置热部署 编写逻辑</span><br><span class="hljs-keyword">if</span> (count&gt;= cartProperties.getMaxAmount())&#123;<br> StrUtil.format(<span class="hljs-string">&quot;用户购物车课程不能超过&#123;&#125;&quot;</span>, cartProperties.getMaxAmount());<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>注册中心-配置中心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringClound</title>
    <link href="/2024/03/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/03/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><h2 id="x-网关"><a href="#x-网关" class="headerlink" title="x. 网关"></a>x. 网关</h2><h3 id="x-1-什么是网关"><a href="#x-1-什么是网关" class="headerlink" title="x.1 什么是网关?"></a>x.1 什么是网关?</h3><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BD%91%E5%85%B3%E6%B5%81%E7%A8%8B.png"></p><hr><h3 id="x-2-快速入门"><a href="#x-2-快速入门" class="headerlink" title="x.2.快速入门"></a>x.2.快速入门</h3><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h4 id="x-2-1-创建网关微服务"><a href="#x-2-1-创建网关微服务" class="headerlink" title="x.2.1 创建网关微服务"></a>x.2.1 创建网关微服务</h4><p>创建Module</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/%E5%BE%AE%E6%9C%8D%E5%8A%A1/966ff8f5b4f16e370f19d5a944f07e4.png"></p><h4 id="1-2-2-导入相关依赖"><a href="#1-2-2-导入相关依赖" class="headerlink" title="1.2.2 导入相关依赖"></a>1.2.2 导入相关依赖</h4><p> 引入SpringCloudGateway、NacosDiscovery依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--common--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kangkang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hm-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--网关--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--nacos discovery--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--负载均衡--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-编写启动类"><a href="#1-2-3-编写启动类" class="headerlink" title="1.2.3 编写启动类"></a>1.2.3 编写启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-2-4-配置网关路由"><a href="#1-2-4-配置网关路由" class="headerlink" title="1.2.4 配置网关路由"></a>1.2.4 配置网关路由</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">kangkang-gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.128</span><span class="hljs-number">.100</span><span class="hljs-string">:8848</span>   <span class="hljs-string">//nacos服务器地址:端口</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">kk-service</span> <span class="hljs-comment">#路由ID，要唯一，建议跟微服务名称一致</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://kk-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/kk/**,/search/**</span>  <span class="hljs-comment">#根据URL的匹配规则路由到具体的服务</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cart-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cart-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/carts/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">pay-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://pay-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/pay-orders/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trade-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://trade-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/orders/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment">#路由ID，要唯一，建议跟微服务名称一致</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/addresses/**,/users/**</span><br></code></pre></td></tr></table></figure><h3 id="1-3-配置全局过滤器"><a href="#1-3-配置全局过滤器" class="headerlink" title="1.3 配置全局过滤器"></a>1.3 配置全局过滤器</h3><h4 id="1-3-1-创建过滤器类-AutoGlobalFilter"><a href="#1-3-1-创建过滤器类-AutoGlobalFilter" class="headerlink" title="1.3.1 创建过滤器类 AutoGlobalFilter"></a>1.3.1 创建过滤器类 AutoGlobalFilter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.gateway.filters;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-comment">//配置过滤逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AutoGlobalFilter全局过滤器生效了!&quot;</span>);<br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>    <span class="hljs-comment">//设置排序</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-3-2-暂未编写过滤逻辑-通过访问购物车测试过滤器"><a href="#1-3-2-暂未编写过滤逻辑-通过访问购物车测试过滤器" class="headerlink" title="1.3.2 (暂未编写过滤逻辑) 通过访问购物车测试过滤器"></a>1.3.2 (暂未编写过滤逻辑) 通过访问购物车测试过滤器</h4><p><a href="http://localhost:8080/carts">localhost:8080&#x2F;carts</a></p><p>排序为0  生效中</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">AutoGlobalFilter全局过滤器生效了!<br>PrintAnyGatewayFilterFactory生效了<br>kk:kk666<br>k:k888<br><span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">21</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">11.731</span>  INFO <span class="hljs-number">14992</span> --- <span class="hljs-selector-attr">[ent-executor-15]</span> com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.nacos</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.client</span>   : <span class="hljs-selector-attr">[a5a8dc66-3b0d-489d-a4c4-7c99412d58bc]</span> Receive server push request, request = NotifySubscriberRequest, requestId = <span class="hljs-number">23</span><br><span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">21</span> <span class="hljs-number">11</span>:<span class="hljs-number">33</span>:<span class="hljs-number">11.733</span>  INFO <span class="hljs-number">14992</span> --- <span class="hljs-selector-attr">[ent-executor-15]</span> com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.nacos</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.remote</span><span class="hljs-selector-class">.client</span>   : <span class="hljs-selector-attr">[a5a8dc66-3b0d-489d-a4c4-7c99412d58bc]</span> Ack server push request, request = NotifySubscriberRequest, requestId = <span class="hljs-number">23</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu</title>
    <link href="/2024/03/19/Ubuntu/"/>
    <url>/2024/03/19/Ubuntu/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Ubuntu 是一种基于 Debian 的开源操作系统，它是目前全球范围内使用最广泛的 Linux 发行版之一。Ubuntu 主要由 Canonical 公司开发和维护，其目标是提供一个免费、开放源代码的操作系统，以及一个友好、易于使用的用户界面。</p><h2 id="x-疑难解答"><a href="#x-疑难解答" class="headerlink" title="x.疑难解答"></a>x.疑难解答</h2><h3 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1.Docker"></a>1.Docker</h3><h4 id="问题-安装docker时发生挂载目录为只读"><a href="#问题-安装docker时发生挂载目录为只读" class="headerlink" title="问题:安装docker时发生挂载目录为只读"></a>问题:安装docker时发生挂载目录为只读</h4><p>原因:  docker可能为<code>Snap</code> 安装,这种情况docker只对用户目录有读写权限</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2024/03/18/Maven/"/>
    <url>/2024/03/18/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Maven是一个项目管理工具，它可以帮助我们构建、发布和管理Java项目。通过一个项目对象模型（POM）文件来描述项目，其中包含了项目的配置信息，依赖管理等。</p><h2 id="2-配置Maven"><a href="#2-配置Maven" class="headerlink" title="2.配置Maven"></a>2.配置Maven</h2><h3 id="2-1-设置本地仓库"><a href="#2-1-设置本地仓库" class="headerlink" title="2.1 设置本地仓库"></a>2.1 设置本地仓库</h3><p>配置文件目录<code>/conf/settings.xml</code></p><p>Maven 的默认本地路径 <code>$&#123;user.home&#125;/.m2/repository</code> 注意仓库本身请选择一个<strong>没有中文</strong>的文件路径.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--  localRepository</span><br><span class="hljs-comment">   | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">   |</span><br><span class="hljs-comment">   | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">   --&gt;</span><br><span class="hljs-comment">&lt;!--  改成你自己的本地仓库的路径  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-comment">&lt;!--  interactiveMode</span><br></code></pre></td></tr></table></figure><h3 id="2-2-设置私服Nexus"><a href="#2-2-设置私服Nexus" class="headerlink" title="2.2 设置私服Nexus"></a>2.2 设置私服Nexus</h3><p>设置私服镜像为 阿里云 注意<code>mirror</code>标签不要存在两个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-设置maven的初始JDK版本"><a href="#2-3-设置maven的初始JDK版本" class="headerlink" title="2.3 设置maven的初始JDK版本"></a>2.3 设置maven的初始JDK版本</h3><p>将<code>profile</code>内容复制到<code>profiles</code>标签内</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus</title>
    <link href="/2024/03/15/Mybatis-Plus/"/>
    <url>/2024/03/15/Mybatis-Plus/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="1-什么是MybatisPlus"><a href="#1-什么是MybatisPlus" class="headerlink" title="1. 什么是MybatisPlus"></a>1. 什么是MybatisPlus</h2><p>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h2 id="2-MybatisPlus预先配置"><a href="#2-MybatisPlus预先配置" class="headerlink" title="2.MybatisPlus预先配置"></a>2.MybatisPlus预先配置</h2><h3 id="2-1-导入依赖"><a href="#2-1-导入依赖" class="headerlink" title="2.1 导入依赖"></a>2.1 导入依赖</h3><p>SpringBoot2版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-x-配置yaml"><a href="#2-x-配置yaml" class="headerlink" title="2.x 配置yaml"></a>2.x 配置yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-comment">#设置mapper.xml文件所在位置</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath*:/mapper/**/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.mp.domain.po</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><h3 id="2-x-继承BaseMapper接口"><a href="#2-x-继承BaseMapper接口" class="headerlink" title="2.x  继承BaseMapper接口"></a>2.x  继承BaseMapper接口</h3><p>在需要使用MybatisPlus的Mapper接口中继承BaseMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-使用MybatisPlus"><a href="#3-使用MybatisPlus" class="headerlink" title="3.使用MybatisPlus"></a>3.使用MybatisPlus</h2><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><p>使用BaseMapper中自带的单表查询语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(<span class="hljs-number">5L</span>);<br>        user.setUsername(<span class="hljs-string">&quot;Lucy&quot;</span>);<br>        user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>        user.setPhone(<span class="hljs-string">&quot;18688990011&quot;</span>);<br>        user.setBalance(<span class="hljs-number">200</span>);<br>        user.setInfo(<span class="hljs-string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);<br>        user.setCreateTime(LocalDateTime.now());<br>        user.setUpdateTime(LocalDateTime.now());<br>        userMapper.insert(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelete</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.deleteById(<span class="hljs-number">5L</span>);<br>        System.out.println(<span class="hljs-string">&quot;删除受影响行&quot;</span>+i);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">4L</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUpdateTime(LocalDateTime.now());<br>        user.setUsername(<span class="hljs-string">&quot;Lucy&quot;</span>);<br>        user.setId(<span class="hljs-number">5L</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.updateById(user);<br>        System.out.println(<span class="hljs-string">&quot;更新受影响行&quot;</span>+i);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="x-处理对象属性"><a href="#x-处理对象属性" class="headerlink" title="x.处理对象属性"></a>x.处理对象属性</h3><h4 id="x-1-创建属性对象POJO类"><a href="#x-1-创建属性对象POJO类" class="headerlink" title="x.1 创建属性对象POJO类"></a>x.1 创建属性对象POJO类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.po;<br><br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String intro;<br>    <span class="hljs-keyword">private</span> String gender;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="x-2-这实体类中添加注解"><a href="#x-2-这实体类中添加注解" class="headerlink" title="x.2 这实体类中添加注解"></a>x.2 这实体类中添加注解</h4><p>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="hljs-keyword">private</span> UserInfo info;<br></code></pre></td></tr></table></figure><p>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(value = &quot;tb_user&quot;,autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br></code></pre></td></tr></table></figure><h3 id="x-使用MybatisPlusInterceptor分页插件"><a href="#x-使用MybatisPlusInterceptor分页插件" class="headerlink" title="x. 使用MybatisPlusInterceptor分页插件"></a>x. 使用MybatisPlusInterceptor分页插件</h3><h4 id="x-1-编写拦截器"><a href="#x-1-编写拦截器" class="headerlink" title="x.1 编写拦截器"></a>x.1 编写拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-type">PaginationInnerInterceptor</span> <span class="hljs-variable">paginationInnerInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>();<br>        paginationInnerInterceptor.setMaxLimit(<span class="hljs-number">1000L</span>);<br>        interceptor.addInnerInterceptor(paginationInnerInterceptor);<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="x-2-使用分页插件"><a href="#x-2-使用分页插件" class="headerlink" title="x.2 使用分页插件"></a>x.2 使用分页插件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageSelect</span><span class="hljs-params">()</span>&#123;<br>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//排序规则</span><br>    page.addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;balance&quot;</span>,<span class="hljs-literal">false</span>))<br>            .addOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-literal">true</span>));<br>    Page&lt;User&gt; pageResult = userService.page(page);<br>    System.out.println(<span class="hljs-string">&quot;total:&quot;</span>+ pageResult.getTotal());<br>    System.out.println(<span class="hljs-string">&quot;pages:&quot;</span>+ pageResult.getPages());<br>    List&lt;User&gt; records = pageResult.getRecords();<br>    records.forEach(System.out::println);<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>持久性框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thread Local</title>
    <link href="/2024/03/14/ThreadLocal/"/>
    <url>/2024/03/14/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="Thread-Local"><a href="#Thread-Local" class="headerlink" title="Thread Local"></a>Thread Local</h1><h2 id="1-什么是-Thread-Local-？"><a href="#1-什么是-Thread-Local-？" class="headerlink" title="1.什么是 Thread Local ？"></a>1.什么是 Thread Local ？</h2><p><code>ThreadLocal</code> 是 Java 中的一个类，用于在多线程环境下实现线程局部变量。简单来说，它提供了一种机制，可以使得每个线程都可以拥有自己独立的变量副本，而不必担心线程间的数据共享问题。</p><h2 id="2-为什么需要-Thread-Local？"><a href="#2-为什么需要-Thread-Local？" class="headerlink" title="2.为什么需要 Thread Local？"></a>2.为什么需要 Thread Local？</h2><ol><li>在多线程环境下, 想要获取一个全局变量在不同线程中复用</li><li>在多线程环境下，防止自己的变量被其它线程篡改</li></ol><h2 id="3-使用-Tread-Local"><a href="#3-使用-Tread-Local" class="headerlink" title="3.使用 Tread Local"></a>3.使用 Tread Local</h2><h3 id="3-1-测试Tread-Local"><a href="#3-1-测试Tread-Local" class="headerlink" title="3.1 测试Tread Local"></a>3.1 测试Tread Local</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    <span class="hljs-comment">// 定义一个 ThreadLocal 变量，存储用户名信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; username = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 在主线程中设置用户名为 &quot;kangkang&quot;</span><br>        username.set(<span class="hljs-string">&quot;kangkang&quot;</span>);<br><br>        <span class="hljs-comment">// 创建并启动两个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 在线程1中获取并打印用户名</span><br>            System.out.println(<span class="hljs-string">&quot;Thread1 username: &quot;</span> + username.get());<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 在线程2中设置用户名为 &quot;xiaoming&quot;</span><br>            username.set(<span class="hljs-string">&quot;xiaoming&quot;</span>);<br>            <span class="hljs-comment">// 获取并打印用户名</span><br>            System.out.println(<span class="hljs-string">&quot;Thread2 username: &quot;</span> + username.get());<br>        &#125;);<br><br>        thread1.start();<br>        thread2.start();<br><br>        <span class="hljs-comment">// 主线程获取并打印用户名</span><br>        System.out.println(<span class="hljs-string">&quot;Main thread username: &quot;</span> + username.get());<br><br>        <span class="hljs-comment">// 清除 ThreadLocal 变量</span><br>        username.remove();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-结果"><a href="#3-2-结果" class="headerlink" title="3.2 结果"></a>3.2 结果</h3><p>从这个结果我们可以发现,它是一个数据结构，有点像<code>HashMap</code>，可以保存”<code>key : value</code>“键值对，但是一个Thread Local只能保存一个，并且各个线程的数据互不干扰。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Thread2 username:</span> <span class="hljs-string">xiaoming</span><br><span class="hljs-attr">Thread1 username:</span> <span class="hljs-literal">null</span><br><span class="hljs-attr">Main thread username:</span> <span class="hljs-string">kangkang</span><br></code></pre></td></tr></table></figure><h2 id="4-Thread-Local-源码分析"><a href="#4-Thread-Local-源码分析" class="headerlink" title="4.Thread Local 源码分析"></a>4.Thread Local 源码分析</h2><h3 id="4-1-Set-方法执行流程"><a href="#4-1-Set-方法执行流程" class="headerlink" title="4.1 Set()方法执行流程"></a><strong>4.1 Set()方法执行流程</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">/**currentThread() 用于获取当前正在执行的线程对象实例 该方法被<span class="hljs-doctag">@IntrinsicCandidate</span>注解</span><br><span class="hljs-comment">    表示 它的实现是由底层的本地代码（通常是 C 或 C++）实现的，这样可以更高效地获取当前线程的引用。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先，<code>ThreadLocal</code> 的 <code>set</code> 方法会获取当前线程，使用 <code>Thread.currentThread()</code> 方,来获取当前线程对象实例。</li><li>然后，通过 <code>getMap(t)</code> 方法获取当前线程类的 <code>ThreadLocalMap</code>。这个方法会根据当前线程来获取相应的 <code>ThreadLocalMap</code> 对象，如果当前线程没有对应的 <code>ThreadLocalMap</code>，则会返回 <code>null</code>。</li><li>接下来是关键的一步，在获取到当前线程的 <code>ThreadLocalMap</code> 后，如果这个 <code>map</code> 不为 <code>null</code>，说明当前线程已经有相关的 <code>ThreadLocalMap</code>，则直接调用 <code>map.set(this, value)</code> 方法，将当前 <code>ThreadLocal</code> 对象和对应的值存入 <code>ThreadLocalMap</code> 中。</li><li>如果获取到的 <code>ThreadLocalMap</code> 为 <code>null</code>，说明当前线程还没有创建对应的 <code>ThreadLocalMap</code>，则调用 <code>createMap(t, value)</code> 方法创建一个新的 <code>ThreadLocalMap</code> 并将当前 <code>ThreadLocal</code> 对象和对应的值存入其中。</li></ol><hr><h3 id="4-2-Get-方法执行流程"><a href="#4-2-Get-方法执行流程" class="headerlink" title="4.2 Get()方法执行流程"></a>4.2 Get()方法执行流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/**currentThread() 用于获取当前正在执行的线程对象实例 该方法被<span class="hljs-doctag">@IntrinsicCandidate</span>注解</span><br><span class="hljs-comment">    表示 它的实现是由底层的本地代码（通常是 C 或 C++）实现的，这样可以更高效地获取当前线程的引用。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br>ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先，通过 <code>Thread.currentThread()</code> 获取当前线程对象实例。</li><li>然后，使用 <code>getMap(t)</code> 方法获取当前线程对象实例对应的 <code>ThreadLocalMap</code>。如果当前线程尚未创建 <code>ThreadLocalMap</code>，则执行<code>setInitialValue（）</code> 来返回一个初始值 <code>null</code>。</li><li>如果当前线程已经拥有 <code>ThreadLocalMap</code>，则调用 <code>map.getEntry(this)</code> 方法获取当前 <code>ThreadLocal</code> 实例对应的 <code>Entry</code> 对象。这个 <code>Entry</code> 对象包含了 <code>ThreadLocal</code> 实例和对应的值。</li><li>如果获取到的 <code>Entry</code> 对象不为 <code>null</code>，则将其对应的值强制类型转换为 <code>T</code> 类型并返回。这里使用了 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 注解来抑制未检查的类型转换警告，因为 <code>ThreadLocalMap</code> 的实现中 <code>value</code> 是用 <code>Object</code> 类型存储的。</li><li>如果在 <code>ThreadLocalMap</code> 中没有找到与当前 <code>ThreadLocal</code> 实例关联的值（即获取的 <code>Entry</code> 为 <code>null</code>），则调用 <code>setInitialValue()</code> 方法。这个方法用于设置初始值，通常在第一次调用 <code>get</code> 方法时会执行。</li></ol><h3 id="4-3-Thread-Local-Map-数据结构"><a href="#4-3-Thread-Local-Map-数据结构" class="headerlink" title="4.3 Thread Local Map 数据结构"></a>4.3 Thread Local Map 数据结构</h3><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/ThreadLocal/ThreadLocalMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p><code>ThreadLoalMap</code>是一个类似<code>HashMap</code>的数据结构，但是在<code>ThreadLocal</code>中，并没实现Map接口。</p><p>在<code>ThreadLoalMap</code>中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是<code>ThreadLocal</code>对象，通过<code>ThreadLocal</code>对象的set方法，结果把<code>ThreadLocal</code>对象自己当做key，放进了<code>ThreadLoalMap</code>中。</p><p>这里需要注意的是，<code>ThreadLoalMap</code>的Entry是继承<code>WeakReference</code>，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p><h2 id="5-哈希冲突"><a href="#5-哈希冲突" class="headerlink" title="5. 哈希冲突"></a>5. 哈希冲突</h2><p>我们知道，当发生哈希冲突时，HashMap 会将具有相同哈希值的键值对放置在同一个桶（数组中的一个元素）中，并以链表结构（或树结构，从 JDK 8 开始）存储这些键值对。这样，每个桶可以容纳多个键值对，从而解决了哈希冲突的问题。</p><p>但是<code>ThreadLocalMap</code>只有数组结构 它是如何避免哈希冲突的呢？ </p><h3 id="5-1-Thread-Local-Map-Set-方法执行流程"><a href="#5-1-Thread-Local-Map-Set-方法执行流程" class="headerlink" title="5.1 Thread Local Map Set() 方法执行流程"></a>5.1 Thread Local Map Set() 方法执行流程</h3><p>先看看<code>ThreadLoalMap</code>中插入一个key-value的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>    <br>           Entry[] tab = table;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>                e != <span class="hljs-literal">null</span>;<br>                e = tab[i = nextIndex(i, len)]) &#123;<br>               <span class="hljs-keyword">if</span> (e.refersTo(key)) &#123;<br>                   e.value = value;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br><br>               <span class="hljs-keyword">if</span> (e.refersTo(<span class="hljs-literal">null</span>)) &#123;<br>                   replaceStaleEntry(key, value, i);<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<br><br>           tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>           <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>               rehash();<br>       &#125;<br><br></code></pre></td></tr></table></figure><ol><li><code>tab</code>是<code>table</code>数组的引用，<code>table</code>是<code>ThreadLocalMap</code>中用于存储<code>ThreadLocal</code>变量的数组。</li><li><code>len</code>是<code>table</code>数组的长度。</li><li><code>i</code>是计算出的存储位置索引，通过对<code>ThreadLocal</code>的哈希值取模来确定存储位置,每个<code>ThreadLocal</code>对象都有一个hash值<code>threadLocalHashCode</code>，每初始化一个<code>ThreadLocal</code>对象，hash值就增加一个固定的大小<code>0x61c88647</code>。</li><li>通过循环遍历<code>tab[i]</code>开始的链表，如果发现已经存在相同的<code>ThreadLocal</code>对象，则更新对应的值为新值。</li><li>如果当前位置的<code>ThreadLocal</code>对象为null，说明此位置的Entry已经失效，需要进行替换操作。</li><li>如果遍历结束还没有找到对应的<code>ThreadLocal</code>对象，说明当前位置为空，需要新建一个Entry对象存储该键值对。</li><li>在设置完值之后，如果需要，会进行清理操作和扩容操作。</li></ol><h2 id="6-内存泄露"><a href="#6-内存泄露" class="headerlink" title="6.内存泄露"></a>6.内存泄露</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>      <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>      Object value;<br><br>      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>          <span class="hljs-built_in">super</span>(k);<br>          value = v;<br>      &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><ul><li><code>Entry</code> 类是一个静态内部类。</li><li>它继承自 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，这意味着 <code>Entry</code> 对象持有对 <code>ThreadLocal</code> 对象的弱引用。弱引用的特点是，当 <code>ThreadLocal</code> 对象没有强引用时，即没有其他对象持有它时，该 <code>ThreadLocal</code> 对象可以被垃圾回收。</li><li><code>Entry</code> 类包含了一个 <code>value</code> 字段，用于存储与 <code>ThreadLocal</code> 对象相关联的值。</li><li>构造函数 <code>Entry(ThreadLocal&lt;?&gt; k, Object v)</code> 接收两个参数：<code>k</code> 表示 <code>ThreadLocal</code> 对象，<code>v</code> 表示与之相关联的值。在构造 <code>Entry</code> 对象时，会调用 <code>super(k)</code> 来调用父类 <code>WeakReference</code> 的构造方法，将 <code>ThreadLocal</code> 对象作为参数传递进去，以创建对其的弱引用。同时，将 <code>v</code> 赋值给 <code>value</code> 字段。</li></ul><h2 id="x-x-结论"><a href="#x-x-结论" class="headerlink" title="x.x 结论"></a>x.x 结论</h2><h3 id="x-1-Thread-Local-本身不存值"><a href="#x-1-Thread-Local-本身不存值" class="headerlink" title="x.1 Thread Local 本身不存值"></a>x.1 Thread Local 本身不存值</h3><p>每个 <code>ThreadLocal</code> 实例都持有一个线程局部变量，这个变量的值是线程相关的，并且每个线程都有自己独立的这个值。因此，我们可以说 <code>ThreadLocal</code> 起到了存储值的作用，而线程实例起到了标识这个值的键的作用。</p><p>在<code>ThreadLocalMap</code>中的entry键值对存储的就是 Key <code>ThreadLocal</code>实例 和  其关联的值</p><h3 id="x-2-Thread-Local-Map是线程自己的局部变量"><a href="#x-2-Thread-Local-Map是线程自己的局部变量" class="headerlink" title="x.2 Thread Local Map是线程自己的局部变量"></a>x.2 Thread Local Map是线程自己的局部变量</h3><p><code>ThreadLocalMap</code>是每个线程自己的数据结构，用于存储当前线程与<code>ThreadLocal</code>实例关联的值。每个线程都有自己独立的<code>ThreadLocalMap</code>，这样就保证了线程之间的数据隔离性。</p><h3 id="x-3-不适合处理大量数据"><a href="#x-3-不适合处理大量数据" class="headerlink" title="x.3 不适合处理大量数据"></a>x.3 不适合处理大量数据</h3><p>在高度冲突的情况下，<code>set</code>和<code>get</code>操作的效率可能会降低，因为需要不断地寻找下一个空位置或者匹配的<code>Entry</code>对象。这也提醒我们在使用<code>ThreadLocal</code>时要注意避免过多的冲突，可以通过合理设计<code>ThreadLocal</code>对象的哈希值来减少冲突的概率，或者考虑其他数据结构来代替<code>ThreadLocal</code>，以提高效率。</p><p>通过这种设计，我们可以在多线程环境下方便地将线程相关的值与线程关联起来，并且每个线程都可以独立地管理自己的线程本地变量，而不会受到其他线程的影响。</p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>星际公民报错解决</title>
    <link href="/2024/03/07/%E6%98%9F%E9%99%85%E5%85%AC%E6%B0%91%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/03/07/%E6%98%9F%E9%99%85%E5%85%AC%E6%B0%91%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="星际公民报错解决"><a href="#星际公民报错解决" class="headerlink" title="星际公民报错解决"></a>星际公民报错解决</h1><h2 id="1-安装错误"><a href="#1-安装错误" class="headerlink" title="1.安装错误"></a>1.安装错误</h2><p>在要下载的文件夹里面建一个<strong>starcitizen</strong>文件夹，再到<strong>starcitizen</strong>文件夹里面新建一个LIVE文件夹打开启动器用启动器VERIFY一下在点install 可以试试这个方法。</p>]]></content>
    
    
    <categories>
      
      <category>报错解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>StarCitizen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2024/03/06/Nginx/"/>
    <url>/2024/03/06/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="1-提高访问速度"><a href="#1-提高访问速度" class="headerlink" title="1.提高访问速度"></a>1.提高访问速度</h3><p>浏览器重复的请求会被nginx缓冲,直接将数据返回给浏览器,而非访问后端服务器.</p><h3 id="2-进行负载均衡"><a href="#2-进行负载均衡" class="headerlink" title="2.进行负载均衡"></a>2.进行负载均衡</h3><p>在集群服务器中，ngxin可以将访问请求按照指定的方式均衡分配给集群中的服务器.</p><h3 id="3-保证后端服务安全"><a href="#3-保证后端服务安全" class="headerlink" title="3.保证后端服务安全"></a>3.保证后端服务安全</h3><p>避免了前端直接访问后端服务器,保护了后端服务器.</p>]]></content>
    
    
    <categories>
      
      <category>Web服务器</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语句</title>
    <link href="/2024/03/06/SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/03/06/SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL语句的使用"><a href="#SQL语句的使用" class="headerlink" title="SQL语句的使用"></a>SQL语句的使用</h1><h2 id="1-查询语句"><a href="#1-查询语句" class="headerlink" title="1.查询语句"></a>1.查询语句</h2><h3 id="1-1-窗口函数-解决一个分组多个子分组的统计"><a href="#1-1-窗口函数-解决一个分组多个子分组的统计" class="headerlink" title="1.1 窗口函数 解决一个分组多个子分组的统计"></a>1.1 窗口函数 解决一个分组多个子分组的统计</h3><p>窗口函数可以在<strong>不改变原始数据排序或组织方式</strong> 的情况下，根据指定的窗口（也称为分区）对数据进行聚合、排序、排名等操作。</p><p>这个函数用于计算排名，它会为每一行数据分配一个排名值，具体取决于排序规则和分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RANK() OVER (PARTITION BY `date` ORDER BY  pass_count DESC) AS rank_total<br></code></pre></td></tr></table></figure><p>这行代码实现了以下操作：</p><ol><li>首先，使用 <code>PARTITION BY</code> 子句按照 <code>date</code> 字段进行分组。</li><li>接着，使用 <code>ORDER BY</code> 子句按照 <code>pass_count</code> 字段进行降序排序。</li><li>最后，使用 <code>RANK()</code> 函数计算每个分组内按照 <code>pass_count</code> 字段排序后的排名值，并将其命名为 <code>rank_total</code>。</li></ol><p>所以，<code>rank_total</code> 列中的值是根据每个分组内的 <code>pass_count</code> 字段的降序排序顺序计算得出的排名值。</p><h3 id="1-2-TIMESTAMPDIFF-用于计算两个日期之间的差异"><a href="#1-2-TIMESTAMPDIFF-用于计算两个日期之间的差异" class="headerlink" title="1.2 TIMESTAMPDIFF 用于计算两个日期之间的差异"></a>1.2 TIMESTAMPDIFF 用于计算两个日期之间的差异</h3><p><code>TIMESTAMPDIFF</code> 函数是用于计算两个日期或日期时间之间的差异的 MySQL 函数。它返回两个日期之间的差异，以指定的时间单位（例如，天、小时、分钟等）表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TIMESTAMPDIFF(MINUTE,  trade_create_time,trade_complete_time)<br></code></pre></td></tr></table></figure><p>例如，如果想计算从 ‘2024-03-10’ 到 ‘2024-03-15’ 的天数差异，应该这样写：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sqlCopy</span> code<br><span class="hljs-attribute">SELECT</span> TIMESTAMPDIFF(DAY, &#x27;<span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">10</span>&#x27;, &#x27;<span class="hljs-number">2024</span>-<span class="hljs-number">03</span>-<span class="hljs-number">15</span>&#x27;);<br></code></pre></td></tr></table></figure><p>这样可以确保得到正数的天数差异。</p>]]></content>
    
    
    <categories>
      
      <category>数据库语言</category>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringTask</title>
    <link href="/2024/03/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/03/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h1><p>Spring Task 是 Spring Framework 的一部分，用于提供轻量级的任务执行和调度框架。它<strong>不需要单独的依赖</strong>，因为<strong>它包含在 Spring 的核心库</strong>中。如果你使用的是 Spring Boot，那么 Spring Boot 的起步依赖会自动为你管理 Spring Framework 的版本和相应的依赖。</p><h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>在启动项加入 @EnableScheduling 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky;<br><br><span class="hljs-keyword">import</span> ...<br><br><br><span class="hljs-meta">@SpringBootApplication</span><br>@...<br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkyApplication</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SkyApplication.class, args);<br>        log.info(<span class="hljs-string">&quot;server started&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 解决druid 日志报错：discard long time none received connection:xxx</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.setProperty(<span class="hljs-string">&quot;druid.mysql.usePingMethod&quot;</span>,<span class="hljs-string">&quot;false&quot;</span>);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-2-使用SpringTask实现定时任务"><a href="#1-2-使用SpringTask实现定时任务" class="headerlink" title="1.2 使用SpringTask实现定时任务"></a>1.2 使用SpringTask实现定时任务</h3><p>在需要实现的业务中添加 @Scheduled 注解 在cron属性中 填入cron表达式</p><p>案例中的cron表示式为每三秒执行一次日志输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.job;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JobDemo</span> &#123;<br>    <span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>&#123;<br>        log.warn(<span class="hljs-string">&quot;当前时间:&#123;&#125;&quot;</span>, LocalDateTime.now());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/02/25/Redis/"/>
    <url>/2024/02/25/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>Redis 是目前互联网技术领域使用最为广泛的<strong>存储中间件</strong></li><li><strong>数据结构</strong>key-value形式，使用C语言开发</li><li><em>特点</em>:基于<strong>内存存储</strong>,省略了从磁盘读取数据的过程,读写性能高</li><li>由于它的存储的value类型比较丰富,也被称为结构化的NoSql(Not Only SQL)数据库</li></ul><h2 id="x-在SpringBoot中使用Redis缓存"><a href="#x-在SpringBoot中使用Redis缓存" class="headerlink" title="x.在SpringBoot中使用Redis缓存"></a>x.在SpringBoot中使用Redis缓存</h2><h3 id="导入Redis依赖"><a href="#导入Redis依赖" class="headerlink" title="导入Redis依赖"></a>导入Redis依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置application.yml文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>RedisCRUD操作失败导致整个数据库事务失败</p><p>使用try catch捕获异常</p><h2 id="x-Redis-命令"><a href="#x-Redis-命令" class="headerlink" title="x. Redis 命令"></a>x. Redis 命令</h2><h3 id="INCR-原子"><a href="#INCR-原子" class="headerlink" title="INCR(原子)"></a>INCR(原子)</h3>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jwt</title>
    <link href="/2024/01/30/Jwt/"/>
    <url>/2024/01/30/Jwt/</url>
    
    <content type="html"><![CDATA[<h1 id="Json-Web-Token（Jwt）"><a href="#Json-Web-Token（Jwt）" class="headerlink" title="Json Web Token（Jwt）"></a>Json Web Token（Jwt）</h1><h2 id="1-Jwt介绍"><a href="#1-Jwt介绍" class="headerlink" title="1.Jwt介绍"></a>1.Jwt介绍</h2><p>JSON Web Token，简称 <a href=""><strong>JWT</strong></a>，读音是 [dʒɒt]（ jot 的发音），是一个基于 RFC 7519 的开放数据标准，它定义了一种宽松且紧凑的数据组合方式。其作用是：<strong>JWT是一种加密后数据载体，可在各应用之间进行数据传输</strong>。</p><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="2-Jwt组成"><a href="#2-Jwt组成" class="headerlink" title="2.Jwt组成"></a>2.Jwt组成</h2><h3 id="2-1-Jwt结构"><a href="#2-1-Jwt结构" class="headerlink" title="2.1 Jwt结构"></a>2.1 Jwt结构</h3><p>以 . 分隔分为三个部分.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span> <span class="hljs-comment">//头部</span><br>.eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiaWF<span class="hljs-number">0</span>Ijox<span class="hljs-symbol">NTE2</span>Mj<span class="hljs-name">M5</span>MDIyfQ <span class="hljs-comment">//载荷</span><br>.SflKxwRJSMeKKF<span class="hljs-number">2</span>QT<span class="hljs-number">4</span>fwpMeJf<span class="hljs-number">36</span>POk<span class="hljs-number">6</span>yJV_adQssw<span class="hljs-number">5</span>c <span class="hljs-comment">//签名</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Jwt令牌验证方式"><a href="#2-2-Jwt令牌验证方式" class="headerlink" title="2.2 Jwt令牌验证方式"></a>2.2 Jwt令牌验证方式</h3><ol><li><strong>获取 JWT</strong>：从HTTP请求中获取JWT令牌。</li><li><strong>解析 JWT</strong>：使用工具类将JWT令牌解析成头部、载荷和签名三个部分。</li><li><strong>Base64 解码</strong>：对获取的JWT头部和载荷部分进行Base64解码，得到原始的 JSON 格式数据。（注意头部和载荷只是使用Base64编码这个是可逆的）</li><li><strong>验证签名</strong>：使用相同的算法、服务器自己的密钥和获取的Jwt头部、载荷部分，重新计算签名。</li><li><strong>比较签名</strong>：将重新计算得到的签名与JWT中的签名进行比较。如果两者一致，则认为JWT是有效的，否则认为JWT是无效的。</li></ol><hr><h2 id="3-Jwt的特性"><a href="#3-Jwt的特性" class="headerlink" title="3.Jwt的特性"></a>3.Jwt的特性</h2><h3 id="3-1无状态性"><a href="#3-1无状态性" class="headerlink" title="3.1无状态性"></a>3.1无状态性</h3><p>JWT 不需要在服务端存储任何状态，客户端可以携带 JWT 来访问服务端，从而使服务端变得无状态。这样，服务端就可以更轻松地实现扩展和负载均衡。</p><h4 id="传统登录（有状态性）："><a href="#传统登录（有状态性）：" class="headerlink" title="传统登录（有状态性）："></a><strong>传统登录（有状态性）</strong>：</h4><ol><li><p><strong>登录过程</strong>：用户提供用户名和密码，认证服务器验证用户身份，并在服务器端创建一个会话。通常，服务器生成一个会话标识符（session ID），将该标识符发送给客户端。</p></li><li><p><strong>状态存储</strong>：服务器端存储有关用户的会话信息，包括用户身份、权限、登录状态等。会话信息可以存储在服务器的内存、数据库或其他持久化存储中。</p></li><li><p><strong>后续请求</strong>：客户端在后续的请求中携带会话标识符，服务器通过该标识符识别并验证用户的身份，维护用户的登录状态。</p></li></ol><h4 id="JWT（无状态性）："><a href="#JWT（无状态性）：" class="headerlink" title="JWT（无状态性）："></a><strong>JWT（无状态性）：</strong></h4><ol><li><p><strong>登录过程</strong>：用户提供用户名和密码，认证服务器验证用户身份后，生成一个包含用户信息的JWT，并将该JWT发送给客户端。</p></li><li><p><strong>状态存储</strong>：服务器不需要在后端存储用户的会话状态。JWT 是自包含的，包含了用户信息和签名，服务器无需存储额外信息。</p></li><li><p><strong>后续请求</strong>：客户端在后续的请求中携带JWT，服务器通过验证JWT的签名来确认用户的身份，无需再次查询数据库或维护会话状态。</p></li></ol><h3 id="3-2-可自定义"><a href="#3-2-可自定义" class="headerlink" title="3.2 可自定义"></a>3.2 可自定义</h3><p>JWT 的载荷部分可以自定义，可以存储任何 JSON 格式的数据。这意味着我们可以使用 JWT 来实现一些自定义的功能，例如存储用户喜好、配置信息等等。 </p><h3 id="3-3-扩展性强"><a href="#3-3-扩展性强" class="headerlink" title="3.3 扩展性强"></a>3.3 扩展性强</h3><p>JWT 有一套标准规范，因此很容易在不同平台和语言之间共享和解析。此外，开发人员可以根据需要自定义声明（claims）来实现更加灵活的功能。</p><h3 id="3-4-调试性好"><a href="#3-4-调试性好" class="headerlink" title="3.4 调试性好"></a>3.4 调试性好</h3><p>JWT 有一个简单而可读的结构，由三部分组成：头部、载荷和签名。每个部分都是Base64编码的JSON字符串，这使得开发人员能够轻松查看 JWT 的内容，了解其中包含的信息。</p><h3 id="3-5-安全性取决于密钥管理"><a href="#3-5-安全性取决于密钥管理" class="headerlink" title="3.5 安全性取决于密钥管理"></a>3.5 安全性取决于密钥管理</h3><p>JWT 的安全性取决于密钥的管理。如果密钥被泄露或者被不当管理，他人就可以通过密钥自行生成所需的Jwt,来代替用户执行其他非法操作，因此，在使用 JWT 时，一定要注意密钥的管理，包括生成、存储、更新、分发等等。</p><h3 id="3-6-无法撤销"><a href="#3-6-无法撤销" class="headerlink" title="3.6 无法撤销"></a>3.6 无法撤销</h3><p>由于 JWT 是无状态的，一旦 JWT 被签发，就无法撤销。如果用户在使用 JWT 认证期间被注销或禁用，那么服务端就无法阻止该用户继续使用之前签发的 JWT。因此，开发人员需要设计额外的机制来撤销 JWT，例如使用黑名单或者设置短期有效期等等。</p><h3 id="3-7-需要缓存到客户端"><a href="#3-7-需要缓存到客户端" class="headerlink" title="3.7 需要缓存到客户端"></a>3.7 需要缓存到客户端</h3><p>当客户端向认证服务器发送登录请求以及所需信息时,返回给用户的Jwt一般需要客户端缓存，这意味着 他人有可能窃取用户的Jwt进行登录操作。</p><h3 id="3-8-载荷大小有限制"><a href="#3-8-载荷大小有限制" class="headerlink" title="3.8 载荷大小有限制"></a>3.8 载荷大小有限制</h3><p>由于 JWT 需要传输到客户端，因此载荷大小也有限制。一般不建议载荷超过 1KB，会影响性能。</p><h2 id="4-Jwt的优缺点"><a href="#4-Jwt的优缺点" class="headerlink" title="4.Jwt的优缺点"></a>4.Jwt的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul><li><p><strong>无状态</strong>：JWT 本身不需要存储在服务器上，因此可以实现无状态的身份验证和授权。</p></li><li><p>可扩展性：JWT 的载荷可以自定义，因此可以根据需求添加任意信息。</p></li><li><p>可靠性：JWT 使用数字签名来保证安全性，只要因此具有可靠性。</p></li><li><p>跨平台性：JWT 支持多种编程语言和操作系统，因此具有跨平台性。</p></li><li><p><strong>高效性</strong>：由于 JWT 不需要查询数据库，因此具有高效性。</p><p>PS:</p><p><strong>无状态性</strong>:集群模式的横向扩展（多个服务器）上,传统登录需要考虑多台服务器用户会话信息的数据同步问题,因为服务器需要用户会话信息认证,而Jwt则无需考虑,因为Jwt每个请求都包含了所有必要的信息，无需在集群中共享会话状态。</p><p><strong>高效性</strong>: 如下图所示 当客户端通过认证服务器获取Jwt之后,之后在Jwt生效的时段中都可以直接进行Jwt验证,免去了与数据库的交互</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/Jwt/Jwt%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p></li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul><li><p>安全性取决于密钥管理：JWT 的安全性取决于密钥的管理，如果密钥被泄露或者被不当管理，那么 JWT 将会受到攻击。</p></li><li><p>无法撤销令牌：由于 JWT 是无状态的，一旦 JWT 被签发，就无法撤销。</p></li><li><p>需要传输到客户端：由于 JWT 包含了用户信息和授权信息，因此 JWT 需要传输到客户端，这意味着 JWT 有被攻击者窃取的风险,比如<strong>重放攻击</strong>。</p></li><li><p>载荷大小有限制：由于 JWT 需要传输到客户端，因此载荷大小也有限制。</p><p>PS：</p><p><strong>重放攻击</strong>: 攻击者截获并重复使用先前传输的有效消息或令牌的攻击方式。在JWT的场景下，如果攻击者能够截获有效的JWT并在有效期内重复使用，这可能导致一些安全问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Jwt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一个模板</title>
    <link href="/2024/01/26/ElasticSerach/"/>
    <url>/2024/01/26/ElasticSerach/</url>
    
    <content type="html"><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 自动配置原理</title>
    <link href="/2024/01/26/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/26/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h1><h2 id="1-什么是SpringBoot的自动配置？"><a href="#1-什么是SpringBoot的自动配置？" class="headerlink" title="1.什么是SpringBoot的自动配置？"></a>1.什么是SpringBoot的自动配置？</h2><p>SpringBoot自动配置,英文为Auto-Configuration:</p><ul><li>它是指基于你引入的依赖jar包,对SpringBoot应用进行<strong>自动配置</strong>的</li><li>它为SpringBoot框架的”开箱即用”提供了基础支持</li></ul><h3 id="自动装配与自动配置的区别"><a href="#自动装配与自动配置的区别" class="headerlink" title="自动装配与自动配置的区别"></a>自动装配与自动配置的区别</h3><p><em><strong>自动装配</strong>(AutoWire)与</em><em>自动配置</em><em>(Auto-Configuration)是两个概念</em></p><ul><li><p><strong>自动装配</strong>: 针对的是Spring中的依赖注入</p></li><li><p><strong>自动配置</strong>:  针对的是SpringBoot中的<strong>配置类</strong></p></li></ul><p>补充:</p><p>我们经常提到的<strong>配置类</strong>（Configuration Class）也有广义与狭义的区别:</p><ul><li>广义上的”<strong>配置类</strong>“:   被注解@Component 直接或间接修饰的某个类,即Spring的组件,其中就包含了被@Configuration修饰的类。</li><li>狭义上的”配置类”:   特指被@Configuration注解修饰的类。</li></ul><hr><h2 id="2-SpringBoot导入第三方maven依赖"><a href="#2-SpringBoot导入第三方maven依赖" class="headerlink" title="2.SpringBoot导入第三方maven依赖"></a>2.SpringBoot导入第三方maven依赖</h2><p>通常当我们需要在 SpringBoot 中使用阿里云的OSS文件上传功能时，步骤是这样的:</p><h3 id="2-1-导入相关的Starter依赖"><a href="#2-1-导入相关的Starter依赖" class="headerlink" title="2.1 导入相关的Starter依赖"></a>2.1 导入相关的Starter依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 由自己编写的 阿里云OSS文件上传的maven依赖  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kangkang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-配置阿里云OSS"><a href="#2-2-配置阿里云OSS" class="headerlink" title="2.2 配置阿里云OSS"></a>2.2 配置阿里云OSS</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">aliyun:<br>  oss:<br>    endpoint: https://？？？？？.aliyuncs.com<br>    accessKeyId: LTAI5txxxxxxxxX7iM<br>    accessKeySecret: gtdFm？？？？？？sgDKm51fx<br>    bucketName: ？？？？<br>    url: https://？？？？？.oss-cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><h3 id="2-3-直接使用Oss-Template"><a href="#2-3-直接使用Oss-Template" class="headerlink" title="2.3 直接使用Oss Template"></a>2.3 直接使用Oss Template</h3><p>此时SpringBoot就已经将相关Bean对象注入到IOC容器中,可以通过@AutoWired自动注入使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/file&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OssTemplate ossTemplate;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile imageFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> imageFile.getOriginalFilename();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> imageFile.getInputStream();<br>        <span class="hljs-keyword">return</span> ossTemplate.upload(originalFilename, inputStream);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>##3.无启动类实现类自动加载</p><p>在resouce目录下创建Spring.factories目录 </p><p>这些自动配置类通常会在 Spring Boot 应用程序启动时自动生效，它们会根据一定的条件为你的应用程序自动配置一些功能和组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>  com.kangkang.common.exception.ExceptionCatch,\<br>  com.kangkang.common.conf.Swagger2Configuration,\<br>  com.kangkang.common.aliyun.GreenTextScan,\<br>  com.kangkang.common.aliyun.GreenImageScan<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的依赖注入过程</title>
    <link href="/2024/01/26/Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/01/26/Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="测试环境配置"><a href="#测试环境配置" class="headerlink" title="测试环境配置"></a>测试环境配置</h1><h2 id="个人测试环境目录结构"><a href="#个人测试环境目录结构" class="headerlink" title="个人测试环境目录结构"></a>个人测试环境目录结构</h2><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/ProjectImages/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95.png"></p><h2 id="测试环境依赖导入"><a href="#测试环境依赖导入" class="headerlink" title="测试环境依赖导入"></a>测试环境依赖导入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--Spring框架--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h2><h3 id="domain层"><a href="#domain层" class="headerlink" title="domain层"></a>domain层</h3><h4 id="Test01类"><a href="#Test01类" class="headerlink" title="Test01类"></a>Test01类</h4><p>@Component  代表该类被交由Spring容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.domain;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 19:58</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Test02类"><a href="#Test02类" class="headerlink" title="Test02类"></a>Test02类</h4><p>@Component  代表该类被交由Spring容器管理</p><p>@AutoWired  会从Spring容器中寻找匹配的bean来注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.domain;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 19:58</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Test1 name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Spring自动注入:&quot;</span>+name);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="AppConfig配置类"><a href="#AppConfig配置类" class="headerlink" title="AppConfig配置类"></a>AppConfig配置类</h3><p>@ComponentScan 配置组件扫描的基础包路径，Spring 将在这些包中查找标有 @Component 注解的类。</p><p>@Configuration 表明该类是一个配置类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.kangkang;<br><br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 20:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ComponentScan(<span class="hljs-string">&quot;com.kangkang&quot;</span>)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Test-测试类"><a href="#Test-测试类" class="headerlink" title="Test 测试类"></a>Test 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang;<br><br><span class="hljs-keyword">import</span> com.kangkang.domain.Test2;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 20:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>    <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>      <br>        <span class="hljs-type">Test2</span> <span class="hljs-variable">test4</span> <span class="hljs-operator">=</span> (Test2) application.getBean(Test2.class);<br>        test2.test();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="具体执行步骤"><a href="#具体执行步骤" class="headerlink" title="具体执行步骤"></a>具体执行步骤</h2><p>程序会从Test测试类开始  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br></code></pre></td></tr></table></figure><ol><li><p>首先会创建一个AnnotationConfigApplicationContext对象 ，这个类是ApplicationContex这个接口的实现类</p><hr></li><li><p>ApplicationContext继承了BeanFactory，这个BeanFactory才是<strong>真正</strong>去制造bean的，之后的ApplicationContext、AnnotationConfigApplicationContext都是在它的基础上提供了更多的功能，如事件发布、国际化、AOP 等，使得它更适合用于企业级应用程序的开发。</p><hr></li><li><p>AnnotationConfigApplicationContext会根据传入参数的AppConfig.class中的@ ComponentScan这个注解中的包路径去寻找是否带@Component注解的类，以及获取类的所有属性以及方法来确认是否有@AutoWired注解或其他注解 （）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.kangkang&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr></li><li><p>这个时候就会根据@Component注解往Spring容器中注入两个bean,(一个Test01一个Test02) 而Test02中的@AutoWired注解会从容器中得到之前注入的Test01bean,注入到Test02中的name属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> Test1 name;<br></code></pre></td></tr></table></figure><ol><li><p><strong>在容器中查找 Bean 定义：</strong> Spring 容器会根据传入的类型 <code>Test2.class</code> 在容器中查找对应的 Bean 定义。这可以是通过注解标记的类（例如 <code>@Component</code>、<code>@Service</code> 等），也可以是通过 Java 配置类中的 <code>@Bean</code> 方法定义的。</p></li><li><p><strong>实例化 Bean：</strong> 如果找到了匹配的 Bean 定义，Spring 会实例化一个 <code>Test2</code> 类型的对象。这可能涉及到构造函数的调用，依赖项的注入等。</p></li><li><p><strong>注入依赖项：</strong> 如果 <code>Test2</code> 类中有其他依赖项（通过构造函数、字段或方法注入），Spring 会尝试解析这些依赖项并递归地注入它们。</p></li><li><p><strong>返回 Bean 实例：</strong> 最终，<code>getBean(Test2.class)</code> 方法会返回类型为 <code>Test2</code> 的 bean 实例。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Test2 test4 <span class="hljs-operator">=</span> (Test2) application.getBean(Test2.class)<span class="hljs-comment">;</span><br>test2.test()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意Spring中默认模式是单例的也就是说每个bean都是唯一的,可以通过debug一下来演示,可以看见每个对象都是一样的 Test2@1869</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/ProjectImages/Spring%E5%A4%9A%E4%B8%AAbean%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA.jpg"></p><hr></li></ol></li><li><p>最后通过Test2bean对象成功调用Test 输出Test01的对象</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">Spring自动注入:<span class="hljs-keyword">com</span>.kangkang.domain.Test1<span class="hljs-subst">@8458</span>f04<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2024/01/26/docker/"/>
    <url>/2024/01/26/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一个模板</title>
    <link href="/2024/01/26/Vim/"/>
    <url>/2024/01/26/Vim/</url>
    
    <content type="html"><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一个模板</title>
    <link href="/2024/01/26/%E6%A8%A1%E6%9D%BF/"/>
    <url>/2024/01/26/%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Filter和Interceptor</title>
    <link href="/2024/01/26/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2024/01/26/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Filter过滤器和拦截器Interceptor"><a href="#Filter过滤器和拦截器Interceptor" class="headerlink" title="Filter过滤器和拦截器Interceptor"></a>Filter过滤器和拦截器Interceptor</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>过滤器和拦截器,在功方面很类似,但在具体实现方面差距还是很大；</p><p>过滤器出现的时间早于拦截器</p><h2 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-过滤器"><a href="#3-过滤器" class="headerlink" title="3. 过滤器"></a>3. 过滤器</h2><p>需求: 统计每个ip访问某个controller的次数</p><h3 id="3-1-编写逻辑"><a href="#3-1-编写逻辑" class="headerlink" title="3.1 编写逻辑"></a>3.1 编写逻辑</h3><p>注意filter的包路径为 <code>javax.servlet.*</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.health.filter;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>   <span class="hljs-comment">//表示拦截的范围</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myfilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-comment">//将接口转为实现类</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-comment">//通过getRemoteAddr 获取客户端 IP 地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> request.getRemoteAddr();<br><span class="hljs-comment">//获取会话对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//从 HttpSession 对象中获取指定名称的属性值。</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) session.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);<br>        <span class="hljs-comment">//如果count为null则默认1不为null则自增</span><br>        count = Objects.isNull(count)?<span class="hljs-number">1</span>:++count;<br>        System.out.println(<span class="hljs-string">&quot;ip:&quot;</span>+ip+<span class="hljs-string">&quot;\tcount:&quot;</span>+count);<br>        <span class="hljs-comment">//将新的count值存入session中</span><br>        session.setAttribute(<span class="hljs-string">&quot;count&quot;</span>, count);<br><br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-在启动类加上注解"><a href="#3-2-在启动类加上注解" class="headerlink" title="3.2 在启动类加上注解"></a>3.2 在启动类加上注解</h3><p><code>@ServletComponentScan(basePackages = &quot;org.example.filter&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;org.example.filter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(TestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-拦截器"><a href="#3-拦截器" class="headerlink" title="3.拦截器"></a>3.拦截器</h2><p>需求: 统计每个ip访问某个controller的次数</p><h3 id="3-1-编写逻辑-1"><a href="#3-1-编写逻辑-1" class="headerlink" title="3.1 编写逻辑"></a>3.1 编写逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//通过getRemoteAddr 获取客户端 IP 地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> request.getRemoteAddr();<br>        <span class="hljs-comment">//获取会话对象</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//从 HttpSession 对象中获取指定名称的属性值。</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) session.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);<br>        <span class="hljs-comment">//如果count为null则默认1不为null则自增</span><br>        count = Objects.isNull(count)?<span class="hljs-number">1</span>:++count;<br>        System.out.println(<span class="hljs-string">&quot;ip:&quot;</span>+ip+<span class="hljs-string">&quot;\tcount:&quot;</span>+count);<br>        <span class="hljs-comment">//将新的count值存入session中</span><br>        session.setAttribute(<span class="hljs-string">&quot;count&quot;</span>, count);<br><br><span class="hljs-comment">//true表示放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-添加配置类"><a href="#3-2-添加配置类" class="headerlink" title="3.2 添加配置类"></a>3.2 添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.config;<br><br><span class="hljs-keyword">import</span> org.example.MyInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">interceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-type">MyInterceptor</span> <span class="hljs-variable">myInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>();<br>        registry.addInterceptor(myInterceptor) <span class="hljs-comment">//加入拦截器</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">//加入拦截范围</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/login&quot;</span>); <span class="hljs-comment">//不需要拦截的路径</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="x-总结"><a href="#x-总结" class="headerlink" title="x.总结"></a>x.总结</h2><ol><li><code>Filter</code>依赖于<code>Servlet</code>容器,属于<code>Servlet</code>规范的一部分,而<code>Interceptor</code>依赖于SpringMvC框架</li><li><code>Filter</code>的生命周期由<code>Servlet</code>容器管理,而<code>Interceptor</code>通过IOC容器来管理,可通过注入等方式来获取其Bean的实例</li><li><code>Filter</code>可拦截所有web资源(包括Jsp, Servlet,静态资源),而<code>Interceptor</code>则只拦截<code>Controller</code>.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>会用到的配置信息</title>
    <link href="/2024/01/23/Tool/"/>
    <url>/2024/01/23/Tool/</url>
    
    <content type="html"><![CDATA[<p>一些常用配置信息</p><span id="more"></span><h1 id="配置文件信息"><a href="#配置文件信息" class="headerlink" title="配置文件信息"></a>配置文件信息</h1><hr><h2 id="SpringBoot的Application-yml配置"><a href="#SpringBoot的Application-yml配置" class="headerlink" title="SpringBoot的Application.yml配置"></a>SpringBoot的Application.yml配置</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解:"></a>注解:</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#指定Tomcat服务器的端口</span><br><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">8080</span><br><br><br><span class="hljs-meta">#设定该路径下的最小日志等级</span><br><span class="hljs-meta">#这样的配置允许以分层的方式为不同的包和类设置日志级别</span><br><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol">  level:</span><br><span class="hljs-symbol">    com:</span><br><span class="hljs-symbol">      kangkang:</span> debug<br><br><span class="hljs-meta">#spring:</span><br><span class="hljs-meta">#  datasource:</span><br><span class="hljs-meta">#    设置数据库驱动类的全限定类名。在这里，指定了 MySQL 的驱动类。</span><br><span class="hljs-meta">#    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">#    设置数据库连接的 URL。这里是连接到 MySQL 数据库的 URL，</span><br><span class="hljs-meta">#    -包括主机地址（127.0.0.1），端口号（3306），数据库名（springboot），以及其他一些连接属性（如字符集、时区等）。</span><br><span class="hljs-meta">#    url: jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="hljs-meta">#    数据库的用户名</span><br><span class="hljs-meta">#    username: root</span><br><span class="hljs-meta">#    数据库的密码</span><br><span class="hljs-meta">#    password: 123456</span><br><br><span class="hljs-meta">#mybatis:</span><br><span class="hljs-meta">#  configuration:</span><br><span class="hljs-meta">#    #开启驼峰映射 将数据库下划线的字段名映射为java的驼峰命名规则</span><br><span class="hljs-meta">#    map-underscore-to-camel-case: true</span><br><span class="hljs-meta">#    #指定MyBatis的日志实现。指定为StdOutImpl</span><br><span class="hljs-meta">#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-meta">#  #指定用于MyBatis的类型别名的基础包路径。这意味着MyBatis将扫描此包及其子包，查找用于类型别名的类。</span><br><span class="hljs-meta">#  type-aliases-package: com.kangkang.boot.domain</span><br><span class="hljs-meta">#  指定Mapper XML文件的位置。在这里，classpath:mapper<span class="hljs-comment">/**/</span>*Mapper.xml</span><br><span class="hljs-meta">#  -表示MyBatis将在类路径下的 mapper 文件夹及其所有子文件夹中查找所有以 Mapper.xml 结尾的文件。这些文件通常包含MyBatis的SQL映射配置。</span><br><span class="hljs-meta">#  mapper-locations: classpath:mapper<span class="hljs-comment">/**/</span>*Mapper.xml</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">kangkang:</span> <span class="hljs-string">debug</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><br><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.kangkang.boot.domain</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/**/*Mapper.xml</span><br></code></pre></td></tr></table></figure><hr><h2 id="Mybatis-Mpper-xml文件配置"><a href="#Mybatis-Mpper-xml文件配置" class="headerlink" title="Mybatis Mpper.xml文件配置"></a>Mybatis Mpper.xml文件配置</h2><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解:"></a>注解:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>： 这是一个文档类型声明（DOCTYPE <span class="hljs-keyword">declaration</span>），指定了 <span class="hljs-keyword">XML</span> 文档的 <span class="hljs-keyword">DTD</span>（文档类型定义）。在这里，它指定了 <span class="hljs-keyword">MyBatis</span> 3.0 版本的 <span class="hljs-keyword">Mapper</span> <span class="hljs-keyword">DTD</span>。</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>： 这部分是 DTD 的具体位置。DTD 文件包含了定义 MyBatis XML 文档结构的规范。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kangkang.boot.mapper.StudentMapper&quot;</span>&gt;</span>： 这是 Mapper XML 文件的根元素，定义了该文件的命名空间。在这里，namespace 属性指定了该 Mapper 文件所属的命名空间，通常与对应的 Mapper 接口的全限定名一致，以便 MyBatis 可以将该 XML 文件与正确的 Mapper 接口关联起来。<br><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kangkang.boot.mapper.StudentMapper&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>配置信息</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
