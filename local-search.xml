<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2024/03/06/nginx/"/>
    <url>/2024/03/06/nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="1-提高访问速度"><a href="#1-提高访问速度" class="headerlink" title="1.提高访问速度"></a>1.提高访问速度</h3><p>浏览器重复的请求会被nginx缓冲,直接将数据返回给浏览器,而非访问后端服务器.</p><h3 id="2-进行负载均衡"><a href="#2-进行负载均衡" class="headerlink" title="2.进行负载均衡"></a>2.进行负载均衡</h3><p>在集群服务器中，ngxin可以将访问请求按照指定的方式均衡分配给集群中的服务器.</p><h3 id="3-保证后端服务安全"><a href="#3-保证后端服务安全" class="headerlink" title="3.保证后端服务安全"></a>3.保证后端服务安全</h3><p>避免了前端直接访问后端服务器,保护了后端服务器.</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语句</title>
    <link href="/2024/03/06/SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/03/06/SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL语句的使用"><a href="#SQL语句的使用" class="headerlink" title="SQL语句的使用"></a>SQL语句的使用</h1><h2 id="1-查询语句"><a href="#1-查询语句" class="headerlink" title="1.查询语句"></a>1.查询语句</h2><h3 id="1-1-窗口函数-解决一个分组多个子分组的统计"><a href="#1-1-窗口函数-解决一个分组多个子分组的统计" class="headerlink" title="1.1 窗口函数 解决一个分组多个子分组的统计"></a>1.1 窗口函数 解决一个分组多个子分组的统计</h3><p>窗口函数可以在<strong>不改变原始数据排序或组织方式</strong> 的情况下，根据指定的窗口（也称为分区）对数据进行聚合、排序、排名等操作。</p><p>这个函数用于计算排名，它会为每一行数据分配一个排名值，具体取决于排序规则和分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RANK() OVER (PARTITION BY `date` ORDER BY  pass_count DESC) AS rank_total<br></code></pre></td></tr></table></figure><p>这行代码实现了以下操作：</p><ol><li>首先，使用 <code>PARTITION BY</code> 子句按照 <code>date</code> 字段进行分组。</li><li>接着，使用 <code>ORDER BY</code> 子句按照 <code>pass_count</code> 字段进行降序排序。</li><li>最后，使用 <code>RANK()</code> 函数计算每个分组内按照 <code>pass_count</code> 字段排序后的排名值，并将其命名为 <code>rank_total</code>。</li></ol><p>所以，<code>rank_total</code> 列中的值是根据每个分组内的 <code>pass_count</code> 字段的降序排序顺序计算得出的排名值。</p>]]></content>
    
    
    <categories>
      
      <category>数据库语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringTask</title>
    <link href="/2024/03/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/03/03/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h1><p>Spring Task 是 Spring Framework 的一部分，用于提供轻量级的任务执行和调度框架。它<strong>不需要单独的依赖</strong>，因为<strong>它包含在 Spring 的核心库</strong>中。如果你使用的是 Spring Boot，那么 Spring Boot 的起步依赖会自动为你管理 Spring Framework 的版本和相应的依赖。</p><h2 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>在启动项加入 @EnableScheduling 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky;<br><br><span class="hljs-keyword">import</span> ...<br><br><br><span class="hljs-meta">@SpringBootApplication</span><br>@...<br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkyApplication</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SkyApplication.class, args);<br>        log.info(<span class="hljs-string">&quot;server started&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 解决druid 日志报错：discard long time none received connection:xxx</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.setProperty(<span class="hljs-string">&quot;druid.mysql.usePingMethod&quot;</span>,<span class="hljs-string">&quot;false&quot;</span>);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-2-使用SpringTask实现定时任务"><a href="#1-2-使用SpringTask实现定时任务" class="headerlink" title="1.2 使用SpringTask实现定时任务"></a>1.2 使用SpringTask实现定时任务</h3><p>在需要实现的业务中添加 @Scheduled 注解 在cron属性中 填入cron表达式</p><p>案例中的cron表示式为每三秒执行一次日志输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.job;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JobDemo</span> &#123;<br>    <span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span>&#123;<br>        log.warn(<span class="hljs-string">&quot;当前时间:&#123;&#125;&quot;</span>, LocalDateTime.now());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="二、实际案例-微信支付超时"><a href="#二、实际案例-微信支付超时" class="headerlink" title="二、实际案例: 微信支付超时"></a>二、实际案例: 微信支付超时</h2><h3 id="2-1-案例代码"><a href="#2-1-案例代码" class="headerlink" title="2.1 案例代码"></a>2.1 案例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.job;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.hxc.pay.CommonPayTemplate;<br><span class="hljs-keyword">import</span> com.hxc.pay.wx.core.WxCommonPayTemplate;<br><span class="hljs-keyword">import</span> com.hxc.pay.wx.service.PaySuccessService;<br><span class="hljs-keyword">import</span> com.sky.mapper.common.OrderMapper;<br><span class="hljs-keyword">import</span> com.sky.pojo.Orders;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注入容器</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderJob</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CommonPayTemplate commonPayTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaySuccessService paySuccessService;<br><br><br><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanNotCancelOrder</span><span class="hljs-params">()</span>&#123;<br>        log.warn(<span class="hljs-string">&quot;--------------扫描15分之前未支付的订单,且微信通知失败的订单--------------&quot;</span>);<br>        <span class="hljs-comment">//获取订单时间  作为判定是否超时的依据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusSeconds(<span class="hljs-number">15</span> * <span class="hljs-number">60</span>);<br>        List&lt;Orders&gt; ordersList = orderMapper.selectByStatusAndOrderTime(Orders.PENDING_PAYMENT, <span class="hljs-literal">null</span>,minTime);<br><br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(ordersList))&#123;<br>            ordersList.forEach(orders -&gt; &#123;<br>                <span class="hljs-comment">//        2.调用微信的查询接口，查询订单的支付状态</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">jsonStr</span> <span class="hljs-operator">=</span> commonPayTemplate.queryOrder(orders.getNumber());<br>                <span class="hljs-type">String</span> <span class="hljs-variable">trade_state</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonStr, Map.class).get(<span class="hljs-string">&quot;trade_state&quot;</span>).toString();<br>                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;SUCCESS&quot;</span>.equals(trade_state))&#123;<br>                    <span class="hljs-comment">// 3.如果是已支付，修改订单状态未已支付</span><br>                    paySuccessService.success(orders.getNumber());<br>                &#125;<br><br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">//如果集合不为空</span><br>    &#125;<br>    <span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanCancelOrder</span><span class="hljs-params">()</span>&#123;<br>        log.warn(<span class="hljs-string">&quot;--------------扫描15分之前未支付的订单--------------&quot;</span>);<br>        <span class="hljs-comment">//获取订单时间  作为判定是否超时的依据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusSeconds(<span class="hljs-number">15</span> * <span class="hljs-number">60</span>);<br>        List&lt;Orders&gt; orders = orderMapper.selectByStatusAndOrderTime(Orders.PENDING_PAYMENT, maxTime,<span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-comment">//如果集合不为空</span><br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(orders)) &#123;<br><br>            orders.forEach(list -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> list.getNumber();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> commonPayTemplate.queryOrder(number);<br>                Map&lt;String, Object&gt; result = JSON.parseObject(json, Map.class);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;NOTPAY&quot;</span>.equals(result.get(<span class="hljs-string">&quot;trade_state&quot;</span>).toString())) &#123;<br>                    commonPayTemplate.close(number);<br>                    <span class="hljs-type">Orders</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> Orders.builder()<br>                            .status(Orders.CANCELLED_ORDER)<br>                            .cancelTime(LocalDateTime.now())<br>                            .cancelReason(<span class="hljs-string">&quot;超时未支付&quot;</span>)<br>                            .number(number)<br>                            .build();<br>                    orderMapper.updateByNumber(build);<br>                &#125;<br>            &#125;);<br><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-2-scanCancelOrder方法解析"><a href="#2-2-scanCancelOrder方法解析" class="headerlink" title="2.2  scanCancelOrder方法解析"></a>2.2  scanCancelOrder方法解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><span class="hljs-comment">//Spring调度框架会自动根据注解参数指定的时间表来执行被注解的方法每三秒执行一次该方法</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanCancelOrder</span><span class="hljs-params">()</span>&#123;<br>     log.warn(<span class="hljs-string">&quot;--------------扫描15分之前未支付的订单--------------&quot;</span>);<br>     <span class="hljs-comment">//获取订单时间  作为判定是否超时的依据 当前时间减去15分钟 </span><br>     <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">maxTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusSeconds(<span class="hljs-number">15</span> * <span class="hljs-number">60</span>);<br>     <span class="hljs-comment">//将maxTime与数据库中的订单时间比对 如果maxTime大于订单时间 并且状态为未支付 则代表支付超时 将订单装入List集合中</span><br>     List&lt;Orders&gt; orders = orderMapper.selectByStatusAndOrderTime(Orders.PENDING_PAYMENT, maxTime,<span class="hljs-literal">null</span>);<br>     <span class="hljs-comment">//如果集合不为空</span><br>     <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(orders)) &#123;<br><span class="hljs-comment">//foreach获取每个订单号</span><br>         orders.forEach(list -&gt; &#123;、<br>             <span class="hljs-comment">//获取订单号</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> list.getNumber();<br>             <span class="hljs-comment">//传入订单号 来获取订单签名</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> commonPayTemplate.queryOrder(number);<br>              <span class="hljs-comment">//将json格式的订单签名转为map的kv格式                 </span><br>             Map&lt;String, Object&gt; result = JSON.parseObject(json, Map.class);<br>              <span class="hljs-comment">//如果超时  并且支付状态为未支付  </span><br>             <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;NOTPAY&quot;</span>.equals(result.get(<span class="hljs-string">&quot;trade_state&quot;</span>).toString())) &#123;<br>                 <span class="hljs-comment">//构造一个HTTP POST请求，向微信支付的关闭订单API发送请求，以关闭一个未支付的订单</span><br>                 commonPayTemplate.close(number);<br>                 <span class="hljs-comment">//编辑参数 修改订单在数据库的状态为取消支付</span><br>                 <span class="hljs-type">Orders</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> Orders.builder()<br>                         .status(Orders.CANCELLED_ORDER)<br>                         .cancelTime(LocalDateTime.now())<br>                         .cancelReason(<span class="hljs-string">&quot;超时未支付&quot;</span>)<br>                         .number(number)<br>                         .build();<br>                 <span class="hljs-comment">//修改数据库</span><br>                 orderMapper.updateByNumber(build);<br>             &#125;<br>         &#125;);<br><br>     &#125;<br><br><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-SQL-语句selectByStatusAndOrderTime"><a href="#2-3-SQL-语句selectByStatusAndOrderTime" class="headerlink" title="2.3  SQL 语句selectByStatusAndOrderTime"></a>2.3  SQL 语句selectByStatusAndOrderTime</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;<span class="hljs-keyword">select</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;selectByStatusAndOrderTime&quot;</span> resultType=<span class="hljs-string">&quot;com.sky.pojo.Orders&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * from orders<br>    &lt;<span class="hljs-built_in">where</span>&gt;<br>        &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;<br>            and status = <span class="hljs-comment">#&#123;status&#125;</span><br>        &lt;/if&gt;<br>        &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;time != null&quot;</span>&gt;<br>            and order_time &amp;lt; <span class="hljs-comment">#&#123;time&#125;</span><br>        &lt;/if&gt;<br>        &lt;<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span>=<span class="hljs-string">&quot;minTime !=null&quot;</span>&gt;<br>            and order_time &amp;gt; <span class="hljs-comment">#&#123;minTime&#125;</span><br>        &lt;/if&gt;<br>    &lt;/where&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h3 id="2-4-scanNotCancelOrder-方法解析"><a href="#2-4-scanNotCancelOrder-方法解析" class="headerlink" title="2.4 scanNotCancelOrder 方法解析"></a>2.4 scanNotCancelOrder 方法解析</h3><p>虽然我们给出了主动通知的接口，但是如果因为网络等原因，导致我们的接口没有被微信主动调用成功，那么我们用户的订单支付成功状态是否就无法能够保障了呢？所以此时我们应该给出兜底方案，一定能够保证用户支付成功的状态是能够获取到的，所以此时我们就需要主动调用查询订单的接口了。如图是微信官方给出的建议：</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%96%87%E7%AB%A0/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/1701190873403.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span><span class="hljs-comment">//Spring调度框架会自动根据注解参数指定的时间表来执行被注解的方法每三秒执行一次该方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanNotCancelOrder</span><span class="hljs-params">()</span>&#123;<br>       log.warn(<span class="hljs-string">&quot;--------------扫描15分之前未支付的订单,且微信通知失败的订单--------------&quot;</span>);<br>       <span class="hljs-comment">//获取订单时间  作为判定是否超时的依据</span><br>       <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> LocalDateTime.now().minusSeconds(<span class="hljs-number">15</span> * <span class="hljs-number">60</span>);<br>      <span class="hljs-comment">// 查找下单未超过 15分  并且未支付的订单</span><br>       List&lt;Orders&gt; ordersList = orderMapper.selectByStatusAndOrderTime(Orders.PENDING_PAYMENT, <span class="hljs-literal">null</span>,minTime);<br><br>       <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(ordersList))&#123;<br>           ordersList.forEach(orders -&gt; &#123;<br>               <span class="hljs-comment">//        2.调用微信的查询接口，查询订单的支付状态</span><br>               <span class="hljs-type">String</span> <span class="hljs-variable">jsonStr</span> <span class="hljs-operator">=</span> commonPayTemplate.queryOrder(orders.getNumber());<br>               <span class="hljs-type">String</span> <span class="hljs-variable">trade_state</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonStr, Map.class).get(<span class="hljs-string">&quot;trade_state&quot;</span>).toString();<br>               <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;SUCCESS&quot;</span>.equals(trade_state))&#123;<br>                   <span class="hljs-comment">// 3.如果是已支付，修改订单状态为已支付</span><br>                   paySuccessService.success(orders.getNumber());<br>               &#125;<br><br>           &#125;);<br>       &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/02/25/Redis/"/>
    <url>/2024/02/25/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ul><li>Redis 是目前互联网技术领域使用最为广泛的<strong>存储中间件</strong></li><li><strong>数据结构</strong>key-value形式，使用C语言开发</li><li><em>特点</em>:基于<strong>内存存储</strong>,省略了从磁盘读取数据的过程,读写性能高</li><li>由于它的存储的value类型比较丰富,也被称为结构化的NoSql(Not Only SQL)数据库</li></ul><h2 id="在SpringBoot中使用Redis缓存"><a href="#在SpringBoot中使用Redis缓存" class="headerlink" title="在SpringBoot中使用Redis缓存"></a>在SpringBoot中使用Redis缓存</h2><h3 id="导入Redis依赖"><a href="#导入Redis依赖" class="headerlink" title="导入Redis依赖"></a>导入Redis依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置application.yml文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>RedisCRUD操作失败导致整个数据库事务失败</p><p>使用try catch捕获异常</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jwt</title>
    <link href="/2024/01/30/Jwt/"/>
    <url>/2024/01/30/Jwt/</url>
    
    <content type="html"><![CDATA[<h1 id="Json-Web-Token（Jwt）"><a href="#Json-Web-Token（Jwt）" class="headerlink" title="Json Web Token（Jwt）"></a>Json Web Token（Jwt）</h1><h2 id="1-Jwt介绍"><a href="#1-Jwt介绍" class="headerlink" title="1.Jwt介绍"></a>1.Jwt介绍</h2><p>JSON Web Token，简称 <a href=""><strong>JWT</strong></a>，读音是 [dʒɒt]（ jot 的发音），是一个基于 RFC 7519 的开放数据标准，它定义了一种宽松且紧凑的数据组合方式。其作用是：<strong>JWT是一种加密后数据载体，可在各应用之间进行数据传输</strong>。</p><p>互联网服务离不开用户认证。一般流程是下面这样。</p><blockquote><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></blockquote><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="2-Jwt组成"><a href="#2-Jwt组成" class="headerlink" title="2.Jwt组成"></a>2.Jwt组成</h2><h3 id="2-1加密之前"><a href="#2-1加密之前" class="headerlink" title="2.1加密之前"></a>2.1加密之前</h3><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/Jwt/Jwt%E7%BB%93%E6%9E%84.jpg"></p><h3 id="2-2加密之后"><a href="#2-2加密之后" class="headerlink" title="2.2加密之后"></a>2.2加密之后</h3><p>以 . 分隔分为三个部分.</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span> <span class="hljs-comment">//头部</span><br>.eyJzdWIiOiIxMj<span class="hljs-name">M0</span><span class="hljs-symbol">NTY3</span>ODkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span>gR<span class="hljs-name">G9</span>lIiwiaWF<span class="hljs-number">0</span>Ijox<span class="hljs-symbol">NTE2</span>Mj<span class="hljs-name">M5</span>MDIyfQ <span class="hljs-comment">//载荷</span><br>.SflKxwRJSMeKKF<span class="hljs-number">2</span>QT<span class="hljs-number">4</span>fwpMeJf<span class="hljs-number">36</span>POk<span class="hljs-number">6</span>yJV_adQssw<span class="hljs-number">5</span>c <span class="hljs-comment">//签名</span><br></code></pre></td></tr></table></figure><h2 id="3-Jwt的特性"><a href="#3-Jwt的特性" class="headerlink" title="3.Jwt的特性"></a>3.Jwt的特性</h2><h3 id="3-1无状态性"><a href="#3-1无状态性" class="headerlink" title="3.1无状态性"></a>3.1无状态性</h3><p>JWT 不需要在服务端存储任何状态，客户端可以携带 JWT 来访问服务端，从而使服务端变得无状态。这样，服务端就可以更轻松地实现扩展和负载均衡。</p><h4 id="传统登录（有状态性）："><a href="#传统登录（有状态性）：" class="headerlink" title="传统登录（有状态性）："></a><strong>传统登录（有状态性）</strong>：</h4><ol><li><p><strong>登录过程</strong>：用户提供用户名和密码，认证服务器验证用户身份，并在服务器端创建一个会话。通常，服务器生成一个会话标识符（session ID），将该标识符发送给客户端。</p></li><li><p><strong>状态存储</strong>：服务器端存储有关用户的会话信息，包括用户身份、权限、登录状态等。会话信息可以存储在服务器的内存、数据库或其他持久化存储中。</p></li><li><p><strong>后续请求</strong>：客户端在后续的请求中携带会话标识符，服务器通过该标识符识别并验证用户的身份，维护用户的登录状态。</p></li></ol><h4 id="JWT（无状态性）："><a href="#JWT（无状态性）：" class="headerlink" title="JWT（无状态性）："></a><strong>JWT（无状态性）：</strong></h4><ol><li><p><strong>登录过程</strong>：用户提供用户名和密码，认证服务器验证用户身份后，生成一个包含用户信息的JWT，并将该JWT发送给客户端。</p></li><li><p><strong>状态存储</strong>：服务器不需要在后端存储用户的会话状态。JWT 是自包含的，包含了用户信息和签名，服务器无需存储额外信息。</p></li><li><p><strong>后续请求</strong>：客户端在后续的请求中携带JWT，服务器通过验证JWT的签名来确认用户的身份，无需再次查询数据库或维护会话状态。</p></li></ol><h3 id="3-2-可自定义"><a href="#3-2-可自定义" class="headerlink" title="3.2 可自定义"></a>3.2 可自定义</h3><p>JWT 的载荷部分可以自定义，可以存储任何 JSON 格式的数据。这意味着我们可以使用 JWT 来实现一些自定义的功能，例如存储用户喜好、配置信息等等。 </p><h3 id="3-3-扩展性强"><a href="#3-3-扩展性强" class="headerlink" title="3.3 扩展性强"></a>3.3 扩展性强</h3><p>JWT 有一套标准规范，因此很容易在不同平台和语言之间共享和解析。此外，开发人员可以根据需要自定义声明（claims）来实现更加灵活的功能。</p><h3 id="3-4-调试性好"><a href="#3-4-调试性好" class="headerlink" title="3.4 调试性好"></a>3.4 调试性好</h3><p>JWT 有一个简单而可读的结构，由三部分组成：头部、载荷和签名。每个部分都是Base64编码的JSON字符串，这使得开发人员能够轻松查看 JWT 的内容，了解其中包含的信息。</p><h3 id="3-5-安全性取决于密钥管理"><a href="#3-5-安全性取决于密钥管理" class="headerlink" title="3.5 安全性取决于密钥管理"></a>3.5 安全性取决于密钥管理</h3><p>JWT 的安全性取决于密钥的管理。如果密钥被泄露或者被不当管理，他人就可以通过密钥自行生成所需的Jwt,来代替用户执行其他非法操作，因此，在使用 JWT 时，一定要注意密钥的管理，包括生成、存储、更新、分发等等。</p><h3 id="3-6-无法撤销"><a href="#3-6-无法撤销" class="headerlink" title="3.6 无法撤销"></a>3.6 无法撤销</h3><p>由于 JWT 是无状态的，一旦 JWT 被签发，就无法撤销。如果用户在使用 JWT 认证期间被注销或禁用，那么服务端就无法阻止该用户继续使用之前签发的 JWT。因此，开发人员需要设计额外的机制来撤销 JWT，例如使用黑名单或者设置短期有效期等等。</p><h3 id="3-7-需要缓存到客户端"><a href="#3-7-需要缓存到客户端" class="headerlink" title="3.7 需要缓存到客户端"></a>3.7 需要缓存到客户端</h3><p>当客户端向认证服务器发送登录请求以及所需信息时,返回给用户的Jwt一般需要客户端缓存，这意味着 他人有可能窃取用户的Jwt进行登录操作。</p><h3 id="3-8-载荷大小有限制"><a href="#3-8-载荷大小有限制" class="headerlink" title="3.8 载荷大小有限制"></a>3.8 载荷大小有限制</h3><p>由于 JWT 需要传输到客户端，因此载荷大小也有限制。一般不建议载荷超过 1KB，会影响性能。</p><h2 id="4-Jwt的优缺点"><a href="#4-Jwt的优缺点" class="headerlink" title="4.Jwt的优缺点"></a>4.Jwt的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul><li><p><strong>无状态</strong>：JWT 本身不需要存储在服务器上，因此可以实现无状态的身份验证和授权。</p></li><li><p>可扩展性：JWT 的载荷可以自定义，因此可以根据需求添加任意信息。</p></li><li><p>可靠性：JWT 使用数字签名来保证安全性，只要因此具有可靠性。</p></li><li><p>跨平台性：JWT 支持多种编程语言和操作系统，因此具有跨平台性。</p></li><li><p><strong>高效性</strong>：由于 JWT 不需要查询数据库，因此具有高效性。</p><p>PS:</p><p><strong>无状态性</strong>:集群模式的横向扩展（多个服务器）上,传统登录需要考虑多台服务器用户会话信息的数据同步问题,因为服务器需要用户会话信息认证,而Jwt则无需考虑,因为Jwt每个请求都包含了所有必要的信息，无需在集群中共享会话状态。</p><p><strong>高效性</strong>: 如下图所示 当客户端通过认证服务器获取Jwt之后,之后在Jwt生效的时段中都可以直接进行Jwt验证,免去了与数据库的交互</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/Jwt/Jwt%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p></li></ul><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul><li><p>安全性取决于密钥管理：JWT 的安全性取决于密钥的管理，如果密钥被泄露或者被不当管理，那么 JWT 将会受到攻击。</p></li><li><p>无法撤销令牌：由于 JWT 是无状态的，一旦 JWT 被签发，就无法撤销。</p></li><li><p>需要传输到客户端：由于 JWT 包含了用户信息和授权信息，因此 JWT 需要传输到客户端，这意味着 JWT 有被攻击者窃取的风险,比如<strong>重放攻击</strong>。</p></li><li><p>载荷大小有限制：由于 JWT 需要传输到客户端，因此载荷大小也有限制。</p><p>PS：</p><p><strong>重放攻击</strong>: 攻击者截获并重复使用先前传输的有效消息或令牌的攻击方式。在JWT的场景下，如果攻击者能够截获有效的JWT并在有效期内重复使用，这可能导致一些安全问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Jwt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 自动配置原理</title>
    <link href="/2024/01/26/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/26/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>这里写简介</p><span id="more"></span><h1 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h1><h2 id="1-什么是SpringBoot的自动配置？"><a href="#1-什么是SpringBoot的自动配置？" class="headerlink" title="1.什么是SpringBoot的自动配置？"></a>1.什么是SpringBoot的自动配置？</h2><p>SpringBoot自动配置,英文为Auto-Configuration:</p><ul><li>它是指基于你引入的依赖jar包,对SpringBoot应用进行<strong>自动配置</strong>的</li><li>它为SpringBoot框架的”开箱即用”提供了基础支持</li></ul><h3 id="自动装配与自动配置的区别"><a href="#自动装配与自动配置的区别" class="headerlink" title="自动装配与自动配置的区别"></a>自动装配与自动配置的区别</h3><p><em><strong>自动装配</strong>(AutoWire)与</em><em>自动配置</em><em>(Auto-Configuration)是两个概念</em></p><ul><li><p><strong>自动装配</strong>: 针对的是Spring中的依赖注入</p></li><li><p><strong>自动配置</strong>:  针对的是SpringBoot中的<strong>配置类</strong></p></li></ul><p>补充:</p><p>我们经常提到的<strong>配置类</strong>（Configuration Class）也有广义与狭义的区别:</p><ul><li>广义上的”<strong>配置类</strong>“:   被注解@Component 直接或间接修饰的某个类,即Spring的组件,其中就包含了被@Configuration修饰的类。</li><li>狭义上的”配置类”:   特指被@Configuration注解修饰的类。</li></ul><hr><h2 id="2-SpringBoot导入第三方maven依赖"><a href="#2-SpringBoot导入第三方maven依赖" class="headerlink" title="2.SpringBoot导入第三方maven依赖"></a>2.SpringBoot导入第三方maven依赖</h2><p>通常当我们需要在 SpringBoot 中使用阿里云的OSS文件上传功能时，步骤是这样的:</p><h3 id="2-1-导入相关的Starter依赖"><a href="#2-1-导入相关的Starter依赖" class="headerlink" title="2.1 导入相关的Starter依赖"></a>2.1 导入相关的Starter依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 由自己编写的 阿里云OSS文件上传的maven依赖  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.kangkang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-配置阿里云OSS"><a href="#2-2-配置阿里云OSS" class="headerlink" title="2.2 配置阿里云OSS"></a>2.2 配置阿里云OSS</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">aliyun:<br>  oss:<br>    endpoint: https://？？？？？.aliyuncs.com<br>    accessKeyId: LTAI5txxxxxxxxX7iM<br>    accessKeySecret: gtdFm？？？？？？sgDKm51fx<br>    bucketName: ？？？？<br>    url: https://？？？？？.oss-cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><h3 id="2-3-直接使用Oss-Template"><a href="#2-3-直接使用Oss-Template" class="headerlink" title="2.3 直接使用Oss Template"></a>2.3 直接使用Oss Template</h3><p>此时SpringBoot就已经将相关Bean对象注入到IOC容器中,可以通过@AutoWired自动注入使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/file&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OssTemplate ossTemplate;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile imageFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> imageFile.getOriginalFilename();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> imageFile.getInputStream();<br>        <span class="hljs-keyword">return</span> ossTemplate.upload(originalFilename, inputStream);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-SpringBoot自动配置的原理"><a href="#3-SpringBoot自动配置的原理" class="headerlink" title="3.SpringBoot自动配置的原理"></a>3.SpringBoot自动配置的原理</h2><h3 id="3-1-实现自动配置的重要注解"><a href="#3-1-实现自动配置的重要注解" class="headerlink" title="3.1 实现自动配置的重要注解"></a>3.1 实现自动配置的重要注解</h3><h4 id="3-1-1-ComponentScan：是来自Spring框架的一个注解-它的作用是找到符合条件的类。"><a href="#3-1-1-ComponentScan：是来自Spring框架的一个注解-它的作用是找到符合条件的类。" class="headerlink" title="3.1.1 @ComponentScan：是来自Spring框架的一个注解,它的作用是找到符合条件的类。"></a><strong>3.1.1 @ComponentScan</strong>：是来自Spring框架的一个注解,它的作用是找到符合条件的类。</h4><p><strong>使用范例</strong></p><ul><li>在这个例子中，Spring 将扫描 com.example.package1 和 com.example.package2 及其子包中被@Component修饰的组件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.example.package1&quot;, &quot;com.example.package2&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，MyController 和 MyService 类所在的包及其子包将会被扫描，寻找带有 @Component 注解的类，将其纳入 Spring 容器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackageClasses = &#123;MyController.class, MyService.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果你想要扫描一个包，但要排除所有带有 <code>@Controller</code> 注解的类，你可以这样做：</li></ul><p><strong><code>TypeFilter</code>：</strong> 用于按照类型过滤组件。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;com.example.package&quot;</span>, <br>               excludeFilters = <span class="hljs-variable">@ComponentScan</span>.<span class="hljs-built_in">Filter</span>(type = FilterType.ANNOTATION, classes = Controller.class))<br>public class MyApplication &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果你想要扫描一个包，但只包含实现了特定接口的类。你可以这样做：</li></ul><p><strong><code>AssignableTypeFilter</code>：</strong> 用于按照给定类型的子类或接口过滤组件。</p><p>假设有一个接口 <code>MyInterface</code> 和两个实现类 <code>MyImplementation1</code> 和 <code>MyImplementation2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// 接口定义</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImplementation1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// 实现类1的具体实现</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImplementation2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-comment">// 实现类2的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后，使用 <code>@ComponentScan</code> 注解，并在 <code>includeFilters</code> 中添加 <code>AssignableTypeFilter</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ComponentScan</span>(basePackages = <span class="hljs-string">&quot;com.example&quot;</span>,<br>        includeFilters = <span class="hljs-variable">@ComponentScan</span>.<span class="hljs-built_in">Filter</span>(type = FilterType.ASSIGNABLE_TYPE, classes = MyInterface.class))<br>public class AppConfig &#123;<br><br>    <span class="hljs-comment">// 配置类内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@ComponentScan</code> 注解扫描指定包路径下的组件，并使用 <code>AssignableTypeFilter</code> 来过滤出实现了 <code>MyInterface</code> 接口的类。</p><p>记得在 <code>@ComponentScan</code> 注解中使用 <code>includeFilters</code> 属性时，需要将 <code>useDefaultFilters</code> 设置为 <code>false</code>，以确保只使用指定的过滤器。</p><hr><h4 id="3-1-2-Import：是来自Spring框架的一个注解-它的作用是提供一种显式地从其他地方加载配置类的方式，这样可以避免使用性能较差的组件扫描-Component-Scan"><a href="#3-1-2-Import：是来自Spring框架的一个注解-它的作用是提供一种显式地从其他地方加载配置类的方式，这样可以避免使用性能较差的组件扫描-Component-Scan" class="headerlink" title="3.1.2@Import：是来自Spring框架的一个注解,它的作用是提供一种显式地从其他地方加载配置类的方式，这样可以避免使用性能较差的组件扫描(Component Scan)"></a>3.1.2@Import：是来自Spring框架的一个注解,它的作用是提供一种显式地从其他地方加载配置类的方式，这样可以避免使用性能较差的组件扫描(Component Scan)</h4><p>它支持三种导入:</p><ul><li>普通类 </li><li>接口 <strong>ImportSelector</strong>的实现类</li><li>接口 <strong>ImportBeanDefinitionRegistrar</strong>的实现类</li></ul><p>1.普通类范例</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的依赖注入过程</title>
    <link href="/2024/01/26/Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/01/26/Spring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>对依赖注入步骤的概述</p><span id="more"></span><h1 id="测试环境配置"><a href="#测试环境配置" class="headerlink" title="测试环境配置"></a>测试环境配置</h1><h2 id="个人测试环境目录结构"><a href="#个人测试环境目录结构" class="headerlink" title="个人测试环境目录结构"></a>个人测试环境目录结构</h2><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/ProjectImages/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95.png"></p><h2 id="测试环境依赖导入"><a href="#测试环境依赖导入" class="headerlink" title="测试环境依赖导入"></a>测试环境依赖导入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--Spring框架--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h2><h3 id="domain层"><a href="#domain层" class="headerlink" title="domain层"></a>domain层</h3><h4 id="Test01类"><a href="#Test01类" class="headerlink" title="Test01类"></a>Test01类</h4><p>@Component  代表该类被交由Spring容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.domain;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 19:58</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Test02类"><a href="#Test02类" class="headerlink" title="Test02类"></a>Test02类</h4><p>@Component  代表该类被交由Spring容器管理</p><p>@AutoWired  会从Spring容器中寻找匹配的bean来注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang.domain;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 19:58</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Test1 name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Spring自动注入:&quot;</span>+name);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="AppConfig配置类"><a href="#AppConfig配置类" class="headerlink" title="AppConfig配置类"></a>AppConfig配置类</h3><p>@ComponentScan 配置组件扫描的基础包路径，Spring 将在这些包中查找标有 @Component 注解的类。</p><p>@Configuration 表明该类是一个配置类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.kangkang;<br><br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 20:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ComponentScan(<span class="hljs-string">&quot;com.kangkang&quot;</span>)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Test-测试类"><a href="#Test-测试类" class="headerlink" title="Test 测试类"></a>Test 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kangkang;<br><br><span class="hljs-keyword">import</span> com.kangkang.domain.Test2;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: //TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: kangkang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2024-01-26 20:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>  <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>    <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>      <br>        <span class="hljs-type">Test2</span> <span class="hljs-variable">test4</span> <span class="hljs-operator">=</span> (Test2) application.getBean(Test2.class);<br>        test2.test();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="具体执行步骤"><a href="#具体执行步骤" class="headerlink" title="具体执行步骤"></a>具体执行步骤</h2><p>程序会从Test测试类开始  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span>  <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br></code></pre></td></tr></table></figure><ol><li><p>首先会创建一个AnnotationConfigApplicationContext对象 ，这个类是ApplicationContex这个接口的实现类</p><hr></li><li><p>ApplicationContext继承了BeanFactory，这个BeanFactory才是<strong>真正</strong>去制造bean的，之后的ApplicationContext、AnnotationConfigApplicationContext都是在它的基础上提供了更多的功能，如事件发布、国际化、AOP 等，使得它更适合用于企业级应用程序的开发。</p><hr></li><li><p>AnnotationConfigApplicationContext会根据传入参数的AppConfig.class中的@ ComponentScan这个注解中的包路径去寻找是否带@Component注解的类，以及获取类的所有属性以及方法来确认是否有@AutoWired注解或其他注解 （）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.kangkang&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><hr></li><li><p>这个时候就会根据@Component注解往Spring容器中注入两个bean,(一个Test01一个Test02) 而Test02中的@AutoWired注解会从容器中得到之前注入的Test01bean,注入到Test02中的name属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> Test1 name;<br></code></pre></td></tr></table></figure><ol><li><p><strong>在容器中查找 Bean 定义：</strong> Spring 容器会根据传入的类型 <code>Test2.class</code> 在容器中查找对应的 Bean 定义。这可以是通过注解标记的类（例如 <code>@Component</code>、<code>@Service</code> 等），也可以是通过 Java 配置类中的 <code>@Bean</code> 方法定义的。</p></li><li><p><strong>实例化 Bean：</strong> 如果找到了匹配的 Bean 定义，Spring 会实例化一个 <code>Test2</code> 类型的对象。这可能涉及到构造函数的调用，依赖项的注入等。</p></li><li><p><strong>注入依赖项：</strong> 如果 <code>Test2</code> 类中有其他依赖项（通过构造函数、字段或方法注入），Spring 会尝试解析这些依赖项并递归地注入它们。</p></li><li><p><strong>返回 Bean 实例：</strong> 最终，<code>getBean(Test2.class)</code> 方法会返回类型为 <code>Test2</code> 的 bean 实例。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Test2 test4 <span class="hljs-operator">=</span> (Test2) application.getBean(Test2.class)<span class="hljs-comment">;</span><br>test2.test()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意Spring中默认模式是单例的也就是说每个bean都是唯一的,可以通过debug一下来演示,可以看见每个对象都是一样的 Test2@1869</p><p><img src="https://hexo-kang.oss-cn-hangzhou.aliyuncs.com/ProjectImages/Spring%E5%A4%9A%E4%B8%AAbean%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA.jpg"></p><hr></li></ol></li><li><p>最后通过Test2bean对象成功调用Test 输出Test01的对象</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">Spring自动注入:<span class="hljs-keyword">com</span>.kangkang.domain.Test1<span class="hljs-subst">@8458</span>f04<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Filter和Interceptor</title>
    <link href="/2024/01/26/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2024/01/26/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Filter过滤器和拦截器Interceptor"><a href="#Filter过滤器和拦截器Interceptor" class="headerlink" title="Filter过滤器和拦截器Interceptor"></a>Filter过滤器和拦截器Interceptor</h1><p>过滤器和拦截器,在功方面很类似,但在具体实现方面差距还是很大；</p><p>过滤器出现的时间早于拦截器</p><h2 id="在SpringBoot中实现"><a href="#在SpringBoot中实现" class="headerlink" title="在SpringBoot中实现"></a>在SpringBoot中实现</h2><p>需求: 统计每个ip访问某个controller的次数</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="1-创建目录和实例"><a href="#1-创建目录和实例" class="headerlink" title="1.创建目录和实例"></a>1.创建目录和实例</h4><p>在启动类当前目录下创建filter目录创建MyFilter类</p><h4 id="2-实现需求"><a href="#2-实现需求" class="headerlink" title="2.实现需求"></a>2.实现需求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.health.filter;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>   <span class="hljs-comment">//表示拦截的范围</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Myfilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> request.getRemoteAddr();<br><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (Integer) session.getAttribute(<span class="hljs-string">&quot;count&quot;</span>);<br>        count = Objects.isNull(count)?<span class="hljs-number">1</span>:++count;<br>        System.out.println(<span class="hljs-string">&quot;ip:&quot;</span>+ip+<span class="hljs-string">&quot;\tcount:&quot;</span>+count);<br>        session.setAttribute(<span class="hljs-string">&quot;count&quot;</span>, count);<br><br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>会用到的配置信息</title>
    <link href="/2024/01/23/Tool/"/>
    <url>/2024/01/23/Tool/</url>
    
    <content type="html"><![CDATA[<p>一些常用配置信息</p><span id="more"></span><h1 id="配置文件信息"><a href="#配置文件信息" class="headerlink" title="配置文件信息"></a>配置文件信息</h1><hr><h2 id="SpringBoot的Application-yml配置"><a href="#SpringBoot的Application-yml配置" class="headerlink" title="SpringBoot的Application.yml配置"></a>SpringBoot的Application.yml配置</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解:"></a>注解:</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#指定Tomcat服务器的端口</span><br><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">8080</span><br><br><br><span class="hljs-meta">#设定该路径下的最小日志等级</span><br><span class="hljs-meta">#这样的配置允许以分层的方式为不同的包和类设置日志级别</span><br><span class="hljs-symbol">logging:</span><br><span class="hljs-symbol">  level:</span><br><span class="hljs-symbol">    com:</span><br><span class="hljs-symbol">      kangkang:</span> debug<br><br><span class="hljs-meta">#spring:</span><br><span class="hljs-meta">#  datasource:</span><br><span class="hljs-meta">#    设置数据库驱动类的全限定类名。在这里，指定了 MySQL 的驱动类。</span><br><span class="hljs-meta">#    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">#    设置数据库连接的 URL。这里是连接到 MySQL 数据库的 URL，</span><br><span class="hljs-meta">#    -包括主机地址（127.0.0.1），端口号（3306），数据库名（springboot），以及其他一些连接属性（如字符集、时区等）。</span><br><span class="hljs-meta">#    url: jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="hljs-meta">#    数据库的用户名</span><br><span class="hljs-meta">#    username: root</span><br><span class="hljs-meta">#    数据库的密码</span><br><span class="hljs-meta">#    password: 123456</span><br><br><span class="hljs-meta">#mybatis:</span><br><span class="hljs-meta">#  configuration:</span><br><span class="hljs-meta">#    #开启驼峰映射 将数据库下划线的字段名映射为java的驼峰命名规则</span><br><span class="hljs-meta">#    map-underscore-to-camel-case: true</span><br><span class="hljs-meta">#    #指定MyBatis的日志实现。指定为StdOutImpl</span><br><span class="hljs-meta">#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-meta">#  #指定用于MyBatis的类型别名的基础包路径。这意味着MyBatis将扫描此包及其子包，查找用于类型别名的类。</span><br><span class="hljs-meta">#  type-aliases-package: com.kangkang.boot.domain</span><br><span class="hljs-meta">#  指定Mapper XML文件的位置。在这里，classpath:mapper<span class="hljs-comment">/**/</span>*Mapper.xml</span><br><span class="hljs-meta">#  -表示MyBatis将在类路径下的 mapper 文件夹及其所有子文件夹中查找所有以 Mapper.xml 结尾的文件。这些文件通常包含MyBatis的SQL映射配置。</span><br><span class="hljs-meta">#  mapper-locations: classpath:mapper<span class="hljs-comment">/**/</span>*Mapper.xml</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">kangkang:</span> <span class="hljs-string">debug</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><br><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.kangkang.boot.domain</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/**/*Mapper.xml</span><br></code></pre></td></tr></table></figure><hr><h2 id="Mybatis-Mpper-xml文件配置"><a href="#Mybatis-Mpper-xml文件配置" class="headerlink" title="Mybatis Mpper.xml文件配置"></a>Mybatis Mpper.xml文件配置</h2><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解:"></a>注解:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>： 这是一个文档类型声明（DOCTYPE <span class="hljs-keyword">declaration</span>），指定了 <span class="hljs-keyword">XML</span> 文档的 <span class="hljs-keyword">DTD</span>（文档类型定义）。在这里，它指定了 <span class="hljs-keyword">MyBatis</span> 3.0 版本的 <span class="hljs-keyword">Mapper</span> <span class="hljs-keyword">DTD</span>。</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>： 这部分是 DTD 的具体位置。DTD 文件包含了定义 MyBatis XML 文档结构的规范。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kangkang.boot.mapper.StudentMapper&quot;</span>&gt;</span>： 这是 Mapper XML 文件的根元素，定义了该文件的命名空间。在这里，namespace 属性指定了该 Mapper 文件所属的命名空间，通常与对应的 Mapper 接口的全限定名一致，以便 MyBatis 可以将该 XML 文件与正确的 Mapper 接口关联起来。<br><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kangkang.boot.mapper.StudentMapper&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>配置信息</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
